--Configuration
getgenv().Use_Displayname = true -- if true, put accounts displayname for bots | if false use the username of accounts
getgenv().bots = {"Red", "Purple", "Blue", "Green", "Orange"} --bots
getgenv().owner = "JokerMadBoss" --Owner (USER NAME, DO NOT PUT DISPLAYNAME)
getgenv().nbbot = 5 -- Number of bots you want to use
getgenv().prefix = ";" -- Prefix
getgenv().botrender = true -- when true, bots use less CPU
getgenv().printcmd = true -- if true, displays all commands available in the console

--get configs | Important
local Use_Displayname = getgenv().Use_Displayname
local bots = getgenv().bots
local owner = getgenv().owner
local nbbot = getgenv().nbbot
local prefix = getgenv().prefix
local botrender = getgenv().botrender
local printcmd = getgenv().printcmd
local versionfromconfig = getgenv().version

-- cmd, bool and stuff
local cmdstatus = true
local cmdindex = true
local cmdfollow = true
local cmdquit = true
local cmddance = true
local cmdundance = true
local cmdreset = true
local cmdjump = true
local cmdsay = true
local cmdunfollow = true
local cmdreset = true
local cmdorbit = true
local cmdunorbit = true
local cmdgoto = true
local cmdleft = true
local cmdright = true
local cmdws = true
local cmdloopjump = true
local cmdunloopjump = true
local cmdcircle = true
local cmdchannel = true
local cmdworm = true
local cmdunworm = true
local cmdspin = true
local cmdunspin = true
local cmdadmin = true
local cmdunadmin = true
local cmdarch = true
local cmdorbit2 = true
local cmdorbit3 = true
local cmdorbit4 = true
local cmdorbit5 = true
local cmdorbit6 = true
local cmdstalk = true
local cmdunstalk = true
local cmdcmds = true
local cmdtower = true
local cmduntower = true
local cmdfix = true
local cmdfireworks = true
local cmdfling = true
local cmdunfling = true
local cmdexplode = true
local cmdelevator = true
local cmdunelevator = true
local cmdgojo = true
local cmdbridge = true
local cmdunbridge = true
local cmdnuke = true
local cmdsit = true
local cmdunsit = true
local cmdgravity = true
local cmdladder = true
local cmdmine = true
local cmdunmine = true
local cmdragdoll = true
local cmdunragdoll = true
local cmdquake = true
local cmdunquake = true
local cmdsword = true
local cmdunsword = true
local cmdshotgun = true
local cmdunshotgun = true

local towerbool = nil
local followbool = nil
local orbitbool = nil
local orbitbool2 = nil
local orbitbool3 = nil
local orbitbool4 = nil
local orbitbool5 = nil
local orbitbool6 = nil
local leftoffset = nil
local rightoffset = nil
local booljump = nil
local indexcircle = nil
local distance = nil
local channel = nil
local wormbool = nil
local boolspin = nil
local adminbool = nil
local stalkbool = nil
local flingbool = nil
local elevatorbool = nil
local gojobool = nil
local bridgebool = nil
local ladderbool = nil
local minebool = nil
local quakebool = false
local swordbool = nil
local shotgunbool = nil
local Admins = {}

--version of the script
print("Death's bot controller VERSION: 0.3.0")

if printcmd then
  print("Death's Bot Controller - Command List")
  print("-------------------------------------------------------------------")
  print("Arguments Guide:")
  print("[plr]       - Target player (partial username or display name works)")
  print("<number>    - A numerical value required for certain commands")
  print("(string)    - A word or phrase")
  print("-------------------------------------------------------------------")

  print(";status                              | Check if bots are active")
  print(";index                               | Display all bot indexes")
  print(";follow [plr]                        | Bots follow a player")
  print(";unfollow                            | Bots stop following the target")
  print(";quit                                | Disconnects admins/owner from the script")
  print(";dance <number>                      | Bots perform a dance")
  print(";undance                             | Bots stop dancing")
  print(";reset                               | Bots reset themselves")
  print(";jump                                | Bots jump once")
  print(";loopjump                            | Bots continuously jump")
  print(";unloopjump                          | Stop continuous jumping")
  print(";say (sentence)                      | Bots say a message in chat")
  print(";ws <number>                         | Change bots' walk speed")
  print(";channel <number>                    | Select which bot speaks in chat")
  print(";gravity <number>                    | Bots change gravity")
  -- Positioning & Formation Commands
  print(";goto [plr]                          | Bots teleport to a player")
  print(";left [plr]                          | Bots form a line to the left")
  print(";right [plr]                         | Bots form a line to the right")
  print(";circle <number>                     | Bots create a circle around you")
  print(";arch <number>                       | Bots form a half-circle")
  print(";stalk [plr]                         | Bots follow and walk around a player")
  print(";unstalk                             | Stop stalking the player")
  print(";tower [plr]                         | Bots stack into a tower")
  print(";untower                             | Dismantle the tower")
  print(";bridge [plr]                        | Bots form a bridge in front of a player")
  print(";unbridge                            | Remove the bridge")
  print(";worm [plr]                          | Bots form a moving train/snake formation")
  print(";unworm                              | Stop the train formation")
  print(";sit                                 | Bots sit")
  print(";unsit                               | Bots stop sitting")
  -- Orbit & Motion Effects
  print(";orbit [plr] <radius> <speed>        | Bots orbit a player (V1 - Basic)")
  print(";orbit2 [plr] <radius> <speed>       | Bots orbit a player (V2 - Enhanced)")
  print(";orbit3 [plr] <radius> <speed>       | Bots orbit a player (V3)")
  print(";orbit4 [plr] <radius> <speed>       | Bots orbit a player (V4)")
  print(";orbit5 [plr] <radius> <speed>       | Bots orbit a player (V5)")
  print(";orbit6 [plr] <radius> <speed>       | Bots orbit a player (V6 - Chaotic)")
  print(";unorbit                             | Stop bots from orbiting")
  print(";quake [plr] <radius>                | Bots teleport randomly within a radius")
  print(";unquake                             | Bots unquake")
  print(";spin <number>                       | Bots start spinning")
  print(";unspin                              | Bots stop spinning")
  -- Admin Commands
  print(";admin [plr]                         | Grant admin permissions to a player")
  print(";unadmin [plr]                       | Remove admin permissions")
  print(";cmds                                | Display available commands in chat")
  -- Special Effects & Attacks
  print(";fling [plr]                         | Bots teleport to a player and fling them")
  print(";unfling                             | Stop bots from flinging")
  print(";fireworks [plr]                     | Bots launch into the air and explode")
  print(";explode [plr]                       | Bots teleport to a player and explode")
  print(";nuke [plr]                          | Bots descend from above and explode on impact")
  print(";elevator [plr]                      | Bots create a rising platform under a player")
  print(";unelevator                          | Stop the elevator effect")
  print(";ladder [plr]                        | Bots create a ladder infront a player")
  print(";gojo [plr]                          | Bots perform the Hollow Purple sequence")
  print(";sword [plr]                         | Bots sword towards a player")
  print(";unsword                             | Stop bots from swording")
  -- Utility & Fix Commands
  print(";fix                                 | Attempt to fix a bot if glitched")
  print("-------------------------------------------------------------------")
end

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TextChatService = game:GetService("TextChatService")
local VirtualUser = game:GetService("VirtualUser")

local player = game.Players.LocalPlayer
local displayName = player.DisplayName
local user = player.Name
local offset = math.random(0, 360)

local ownerPlayer = game.Players:FindFirstChild(owner)
local adminNotConnected = {}

-- index bot
local index

if Use_Displayname then
  for i, bot in ipairs(bots) do
    if displayName == bot then
      index = i
      break
    end
  end
else
  for i, bot in ipairs(bots) do
    if user == bot then
      index = i
      break
    end
  end
end

-- don't mess with it
if index then
    indexcircle = (360 / nbbot * index)
end

--disable/enable render (less cpu usage)
if index and botrender then
  RunService:Set3dRenderingEnabled(false)
else
  RunService:Set3dRenderingEnabled(true)
end

-- Isindex
if not index then
  if player.Name == owner then
  else
    warn("No bot or owner corresponding with: " .. table.concat(bots, ", ") .. " or " .. owner .. " for this instance.")
    return
  end
end

-- Chat message
local function chatMessage(str)
  str = tostring(str)
  if TextChatService.ChatVersion == Enum.ChatVersion.TextChatService then
    TextChatService.TextChannels.RBXGeneral:SendAsync(str)
  else
    game.ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest:FireServer(str, "All")
  end
end

-- make life easy, with this you don't have to type someone's whole name
local function findPlayerByName(partialName)
  if partialName:lower() == "me" then
    return game.Players:FindFirstChild()
  end

  if partialName:lower() == "random" then
    local players = game.Players:GetPlayers()
    if #players > 0 then
      return players[math.random(1, #players)]
    end
  end

  local bestMatch = nil
  local bestMatchScore = 0

  for _, plr in pairs(game.Players:GetPlayers()) do
    local nameMatch = plr.Name:lower():find(partialName:lower())
    local displayNameMatch = plr.DisplayName:lower():find(partialName:lower())

    if nameMatch or displayNameMatch then
      local score = (nameMatch and #plr.Name or 0) + (displayNameMatch and #plr.DisplayName or 0)
      if score > bestMatchScore then
        bestMatchScore = score
        bestMatch = plr
      end
    end
  end

  return bestMatch
end

--no more bots flinging away with this
local function removeVelocity()
  for _, v in pairs(player.Character:GetDescendants()) do
      if v:IsA("BasePart") then
          v.Velocity = Vector3.new(0, 0, 0)
          v.RotVelocity = Vector3.new(0, 0, 0)
      elseif v:IsA("BodyVelocity") then
          v.Velocity = Vector3.new(0, 0, 0)
      elseif v:IsA("BodyAngularVelocity") then
          v.AngularVelocity = Vector3.new(0, 0, 0)
      elseif v:IsA("BodyPosition") then
          v.Position = v.Position
      elseif v:IsA("BodyGyro") then
          v.CFrame = v.CFrame
      end
  end
end

-- this function make the script a bit more smarter | Important
local function disablebool()
towerbool = false
followbool = false
orbitbool = false
orbitbool2 = false
orbitbool3 = false
orbitbool4 = false
orbitbool5 = false
orbitbool6 = false
booljump = false
wormbool = false
boolspin = false
stalkbool = false
flingbool = false
elevatorbool = false
gojobool = false
bridgebool = false
minebool = false
swordbool = false
ladderbool = false
quakebool = false
shotgunbool = false
end

-- ;fix
local function fix()
removeVelocity()
towerbool = false
followbool = false
orbitbool = false
orbitbool2 = false
orbitbool3 = false
orbitbool4 = false
orbitbool5 = false
orbitbool6 = false
booljump = false
wormbool = false
boolspin = false
stalkbool = false
flingbool = false
elevatorbool = false
gojobool = false
bridgebool = false
ladderbool = false
minebool = false
shotgunbool = false
game.Workspace.Gravity = 196.2
player.Character:BreakJoints()
end

-- ;circle
local function tpcircle(distance)
  if distance == 0 then
    distance = 0.0001 -- yes because you can't divide by 0
  end

  local targetPlayer = Players:FindFirstChild(owner)
  if not targetPlayer or not targetPlayer.Character then
    return
  end

  local targetHumanoidRootPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
  if not targetHumanoidRootPart then
    return
  end

  local player = Players.LocalPlayer
  local playerCharacter = player.Character
  local playerHumanoidRootPart = playerCharacter:FindFirstChild("HumanoidRootPart")
  if not playerHumanoidRootPart then
    return
  end

  removeVelocity()
  local angle = math.rad(0 + indexcircle)
  local offsetX = distance * math.cos(angle)
  local offsetZ = distance * math.sin(angle)
  local newPosition = targetHumanoidRootPart.Position + Vector3.new(offsetX, 0, offsetZ)
  local newCFrame = CFrame.new(newPosition, targetHumanoidRootPart.Position)
  playerHumanoidRootPart.CFrame = newCFrame
end

-- ;arch
local function tparch(distance)
  if distance == 0 then
    distance = 0.0001
  end

  local targetPlayer = Players:FindFirstChild(owner)
  if not targetPlayer or not targetPlayer.Character then
    return
  end

  local targetHumanoidRootPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
  if not targetHumanoidRootPart then
    return
  end
  
  local player = Players.LocalPlayer
  local playerCharacter = player.Character
  local playerHumanoidRootPart = playerCharacter:FindFirstChild("HumanoidRootPart")
  if not playerHumanoidRootPart then
    return
  end
  
  removeVelocity()
  local angle = math.rad(0 + (indexcircle)/2)
  local offsetX = distance * math.cos(angle)
  local offsetZ = distance * math.sin(angle)
  local newPosition = targetHumanoidRootPart.Position + Vector3.new(offsetX, 0, offsetZ)
  local newCFrame = CFrame.new(newPosition, targetHumanoidRootPart.Position)
  playerHumanoidRootPart.CFrame = newCFrame
end

-- ;left
local function left(targetPlayer)
  if not targetPlayer or not targetPlayer.Character then
    return
  end

  local targetHumanoidRootPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
  if not targetHumanoidRootPart then
    return
  end

  if player and player.Character then
    local localHumanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
    if localHumanoidRootPart then

      removeVelocity()
      local offset = targetHumanoidRootPart.CFrame.RightVector * -5 * index  -- NEGATIVE IS LEFT, change this if you want it to go right
      localHumanoidRootPart.CFrame = targetHumanoidRootPart.CFrame + offset
    end
  end
end

-- ;right
local function right(targetPlayer)
  if not targetPlayer or not targetPlayer.Character then
    return
  end

  local targetHumanoidRootPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
  if not targetHumanoidRootPart then
    return
  end

  if player and player.Character then
    local localHumanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
    if localHumanoidRootPart then
      removeVelocity()
      local offset = targetHumanoidRootPart.CFrame.RightVector * 5 * index  -- POSITIVE IS RIGHT, change this if you want it to go left
      localHumanoidRootPart.CFrame = targetHumanoidRootPart.CFrame + offset
    end
  end
end

-- ;sit
local function sit(targetPlayer)
  local humanoid = player.Character and player.Character:FindFirstChild("Humanoid")
  if humanoid then
      humanoid.Sit = true
  end
end

-- ;unsit
local function unsit(targetPlayer)
  local humanoid = player.Character and player.Character:FindFirstChild("Humanoid")
  if humanoid then
      humanoid.Sit = false
  end
end

-- ;goto
local function goto(targetPlayer)
  if not targetPlayer or not targetPlayer.Character then
    return
  end

  local targetHumanoidRootPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
  if not targetHumanoidRootPart then
    return
  end

  if player and player.Character then
    local localHumanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
    if localHumanoidRootPart then
      removeVelocity()
      localHumanoidRootPart.CFrame = targetHumanoidRootPart.CFrame + Vector3.new(0, 0, 0)
    end
  end
end

-- ;ladder
local function ladder(targetPlayer)
  -- Stop any existing ladder connection
  if ladderConnection then
      ladderConnection:Disconnect()
      ladderConnection = nil
  end

  if not targetPlayer or not targetPlayer.Character then
      return nil
  end

  local targetHumanoidRootPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
  if not targetHumanoidRootPart then
      return nil
  end

  -- Set ladder boolean to true
  ladderbool = true
  
  -- Get the bot's index to determine position
  local displayName = player.DisplayName
  local botIndex = table.find(bots, displayName)

  if not botIndex then 
      return nil
  end

  -- Vertical positioning calculation
  local verticalSpacing = 3  -- Space between bots vertically
  local verticalOffset = (botIndex - 1) * verticalSpacing

  -- Distance in front of the player (adjust this value to control proximity)
  local frontOffset = 1  -- Adjust this value to control how far in front the bot stands

  -- Continuous positioning mechanism
  ladderConnection = RunService.Heartbeat:Connect(function()
      -- Check if ladder should continue
      if not ladderbool or not player or not player.Character then
          if ladderConnection then
              ladderConnection:Disconnect()
              ladderConnection = nil
          end
          return
      end

      local localHumanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
      local localHumanoid = player.Character:FindFirstChild("Humanoid")

      if localHumanoidRootPart and targetHumanoidRootPart and localHumanoid then
          -- Get target's current position and rotation
          local targetCFrame = targetHumanoidRootPart.CFrame

          -- Calculate position in front of the player
          -- Use the target's forward vector to position the bot
          local frontPosition = targetCFrame.Position + 
                                (targetCFrame.LookVector * frontOffset) + 
                                Vector3.new(0, verticalOffset, 0)

          -- Create a CFrame that matches the target's rotation and points upward
          local rotatedCFrame = CFrame.new(frontPosition) * 
                                 targetCFrame.Rotation * 
                                 CFrame.Angles(math.rad(180), 0, 0)

          -- Set bot's CFrame in front of the target with the same rotation
          localHumanoidRootPart.CFrame = rotatedCFrame

          -- Remove velocity to prevent drifting
          removeVelocity()
      else
          -- Disconnect if target or bot is missing
          if ladderConnection then
              ladderConnection:Disconnect()
              ladderConnection = nil
          end
      end
  end)

  return ladderConnection
end

-- ;fireworks
local function fireworks(targetPlayer)
  if player and player.Character then
    local humanoid = player.Character:FindFirstChild("Humanoid")
    local humanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
    
    if humanoid and humanoidRootPart then
      -- Apply firework effects
      local Spin = Instance.new("BodyAngularVelocity")
      Spin.Name = "Spinning"
      Spin.Parent = humanoidRootPart
      Spin.MaxTorque = Vector3.new(0, math.huge, 0)
      Spin.AngularVelocity = Vector3.new(0, 45, 0)
      
      local Velocity = Instance.new("BodyVelocity")
      Velocity.Name = "Upward"
      Velocity.Parent = humanoidRootPart
      Velocity.MaxForce = Vector3.new(0, math.huge, 0)
      Velocity.Velocity = Vector3.new(0, 25, 0)
      
      -- Set timer to kill character
      task.delay(2, function()
        if humanoid then
          if Spin then
            Spin:Destroy()
          end
          if Velocity then
            Velocity:Destroy()
          end
          humanoid.Health = 0
        end
      end)
      
      -- Only teleport if target player is specified
      if targetPlayer then
        if targetPlayer.Character then
          local targetHumanoidRootPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
          if targetHumanoidRootPart then
            humanoidRootPart.CFrame = targetHumanoidRootPart.CFrame + Vector3.new(0, 0, 0)
          end
        end
      end
    end
  end
end

-- ;explode
local function explode(targetPlayer)
  local player = game.Players.LocalPlayer
  if not player or not player.Character then return end
  
  local humanoid = player.Character:FindFirstChild("Humanoid")
  local humanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
  
  if not humanoid or not humanoidRootPart then return end
  
  -- Flag to control explosion sequence
  local isExploding = true
  
  -- Create tracking connection
  local explosionConnection
  explosionConnection = game:GetService("RunService").Heartbeat:Connect(function()
      if not isExploding then 
          explosionConnection:Disconnect()
          return 
      end
      
      -- If target player is specified, track them
      if targetPlayer and targetPlayer.Character then
          local targetRootPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
          
          if targetRootPart then
              -- Continuously teleport on top of target
              humanoidRootPart.CFrame = targetRootPart.CFrame * CFrame.new(0, 0, 0)
          end
      else
          -- If no target, add random movement
          local randomOffset = Vector3.new(
              math.random(-0, 0),
              math.random(0, 0),
              math.random(-0, 0)
          )
          humanoidRootPart.CFrame = humanoidRootPart.CFrame * CFrame.new(randomOffset)
      end
      
      -- Spin effect
      local spin = Instance.new("BodyAngularVelocity")
      spin.Name = "ExplodeSpin"
      spin.Parent = humanoidRootPart
      spin.MaxTorque = Vector3.new(0, math.huge, 0)
      spin.AngularVelocity = Vector3.new(0, 235, 0)
      
      -- Upward velocity
      local velocity = Instance.new("BodyVelocity")
      velocity.Name = "ExplodeVelocity"
      velocity.Parent = humanoidRootPart
      velocity.MaxForce = Vector3.new(0, math.huge, 0)
      velocity.Velocity = Vector3.new(0, 20, 0)
  end)
  
  -- Kill character after a delay
  task.delay(0.3, function()
      isExploding = false
      
      -- Remove spin and velocity objects
      local spin = humanoidRootPart:FindFirstChild("ExplodeSpin")
      local velocity = humanoidRootPart:FindFirstChild("ExplodeVelocity")
      
      if spin then spin:Destroy() end
      if velocity then velocity:Destroy() end
      
      -- Kill the character
      if humanoid then
          humanoid.Health = 0
      end
      
      -- Disconnect the tracking connection
      if explosionConnection then
          explosionConnection:Disconnect()
      end
  end)
end

-- ;fling
local function fling(targetPlayer)
  if player and player.Character then
    local humanoid = player.Character:FindFirstChild("Humanoid")
    local humanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
    
    if humanoid and humanoidRootPart then
      -- Apply fling effects
      local Spin = Instance.new("BodyAngularVelocity")
      Spin.Name = "Spinning"
      Spin.Parent = humanoidRootPart
      Spin.MaxTorque = Vector3.new(0, math.huge, 0)
      Spin.AngularVelocity = Vector3.new(0, 1000, 0)
      
      local Velocity = Instance.new("BodyVelocity")
      Velocity.Name = "Upward"
      Velocity.Parent = humanoidRootPart
      Velocity.MaxForce = Vector3.new(0, math.huge, 0)
      Velocity.Velocity = Vector3.new(0, 0, 0)

      flingbool = true

      if targetPlayer then
        -- Loop teleport to target player
        local teleportLoop = game:GetService("RunService").Heartbeat:Connect(function()
          if not flingbool then
            teleportLoop:Disconnect()
            if Spin then
              Spin:Destroy()
            end
            if Velocity then
              Velocity:Destroy()
            end
            return
          end
          
          if targetPlayer.Character then
            local targetHumanoidRootPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
            if targetHumanoidRootPart then
              humanoidRootPart.CFrame = targetHumanoidRootPart.CFrame + Vector3.new(0, 0, 0)
            end
          end
        end)
        
        -- Clean up loop when target dies
        task.spawn(function()
          while targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("Humanoid") and targetPlayer.Character.Humanoid.Health > 0 do
            task.wait()
          end
          teleportLoop:Disconnect()
          
          if humanoid then
            if Spin then
              Spin:Destroy()  
            end
            if Velocity then
              Velocity:Destroy()
            end
          end
        end)
      end
    end
  end
end

-- ;unfling
local function unfling()
  flingbool = false
  if player and player.Character then
    local humanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
    if humanoidRootPart then
      local spin = humanoidRootPart:FindFirstChild("Spinning")
      local velocity = humanoidRootPart:FindFirstChild("Upward")
      
      if spin then
        spin:Destroy()
      end
      if velocity then
        velocity:Destroy()
      end
    end
  end
end

-- ;nuke
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

local function nuke(targetPlayer)
    if not targetPlayer or not targetPlayer.Character then
        return
    end

    local targetHumanoidRootPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not targetHumanoidRootPart then
        return
    end

    -- Spawn directly above the player at a fixed height
    local spawnPosition = targetHumanoidRootPart.Position + Vector3.new(0, 300, 0)

    local player = Players.LocalPlayer
    if player and player.Character then
        local humanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
        if humanoidRootPart then
            -- Teleport to spawn position and set orientation to 90 degrees towards ground
            humanoidRootPart.CFrame = CFrame.new(spawnPosition) * CFrame.Angles(math.rad(90), 0, 0)

            local nukeConnection
            nukeConnection = RunService.Heartbeat:Connect(function()
                if not player or not player.Character or not targetPlayer.Character then
                    nukeConnection:Disconnect()
                    return
                end

                local targetPosition = targetHumanoidRootPart.Position
                local currentPosition = humanoidRootPart.Position

                -- Continuously update horizontal position to follow target
                local newPosition = Vector3.new(
                    targetPosition.X, 
                    currentPosition.Y - 1,  -- Slow descent
                    targetPosition.Z
                )

                -- Maintain 90-degree angle towards ground while following
                humanoidRootPart.CFrame = CFrame.new(newPosition, targetPosition) * CFrame.Angles(math.rad(90), 0, 0)

                -- Check if bot is close to ground
                local raycastParams = RaycastParams.new()
                raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
                raycastParams.FilterDescendantsInstances = {player.Character}

                local raycastResult = workspace:Raycast(
                    humanoidRootPart.Position, 
                    Vector3.new(0, -10, 0), 
                    raycastParams
                )

                if raycastResult and raycastResult.Distance <= 1 then
                    -- Teleport directly onto the target player
                    humanoidRootPart.CFrame = targetHumanoidRootPart.CFrame * CFrame.new(0, 0, 0)

                    local spinVelocity = Instance.new("BodyAngularVelocity")
                    spinVelocity.AngularVelocity = Vector3.new(0, 125, 0)  -- Fixed spin speed
                    spinVelocity.MaxTorque = Vector3.new(0, math.huge, 0)
                    spinVelocity.Parent = humanoidRootPart

                    -- Check if we're on top of the target
                    local distanceToTarget = (humanoidRootPart.Position - targetHumanoidRootPart.Position).Magnitude
                    if distanceToTarget <= 1 then
                        -- Break joints
                        wait(0.25)
                        player.Character:BreakJoints()
                        
                        -- Disconnect the connection
                        nukeConnection:Disconnect()
                    end
                end
            end)
        end
    end
end

-- ;ragdoll
local function ragdoll(targetPlayer)
  local humanoid = player.Character and player.Character:FindFirstChild("Humanoid")
  if humanoid then
      humanoid:ChangeState(Enum.HumanoidStateType.Physics)
  end
end

-- ;unragdoll
local function unragdoll(targetPlayer)
  local humanoid = player.Character and player.Character:FindFirstChild("Humanoid")
  if humanoid then
      humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
  end
end

-- ;gravity
local function setGravity(gravityValue)
  gravityValue = tonumber(gravityValue) or 196.2
  
  game.Workspace.Gravity = gravityValue
end

-- ;gojo
local function gojo(targetPlayer)
  if not targetPlayer or not targetPlayer.Character then
      return
  end

  local targetHumanoidRootPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
  if not targetHumanoidRootPart then
      return
  end

  -- Bot positioning logic
  local displayName = player.DisplayName
  local botIndex = table.find(bots, displayName)
  
  if not botIndex then 
      return 
  end

  -- Precise offset calculations with synchronized movement
  local offset
  local movementProgress = 0  -- Shared movement progress for bot1 and bot3
  local synchronizedMovement = 0  -- Ensures both bots move at exactly the same rate

  if botIndex == 1 then  -- bot1: starts left, moves to middle
      offset = Vector3.new(-10, 0, -3)
  elseif botIndex == 2 then  -- bot2: starts underneath, rises to front of player
      offset = Vector3.new(0, -10, 3)
  elseif botIndex == 3 then  -- bot3: starts right, moves to middle
      offset = Vector3.new(10, 0, -3)
  end

  -- Flags to track bot states
  local middleReached = false
  local bot2ReachedTop = false
  local forwardDistance = 3
  local maxForwardDistance = 50

  -- Continuous positioning mechanism
  local gojoConnection
  gojoConnection = RunService.Heartbeat:Connect(function()
      if not player or not player.Character then
          gojoConnection:Disconnect()
          return
      end

      local localHumanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
      local localHumanoid = player.Character:FindFirstChild("Humanoid")

      if localHumanoidRootPart and targetHumanoidRootPart and localHumanoid then
          local targetCFrame = targetHumanoidRootPart.CFrame
          local finalOffset = offset

          -- Synchronized movement for bot1 and bot3
          if botIndex == 1 or botIndex == 3 then
              -- Increment shared movement progress
              synchronizedMovement = math.min(synchronizedMovement + 0.02, 1)
              
              -- Calculate interpolated offset for both bot1 and bot3
              finalOffset = Vector3.new(
                  offset.X * (1 - synchronizedMovement),
                  offset.Y,
                  offset.Z
              )

              -- When bots reach middle, teleport to front
              if synchronizedMovement >= 1 then
                  middleReached = true
                  finalOffset = Vector3.new(0, 0, 3)
                  disablebool()
                  player.Character:BreakJoints()
              end
          elseif botIndex == 2 then
              -- Existing bot2 movement logic
              if not bot2ReachedTop then
                  finalOffset = Vector3.new(
                      offset.X,
                      offset.Y + (10 * movementProgress),
                      offset.Z
                  )
                  movementProgress = math.min(movementProgress + 0.01, 1)

                  if movementProgress >= 1 then
                      bot2ReachedTop = true
                      movementProgress = 0
                  end
              else
                  forwardDistance = math.min(forwardDistance + 1.5, maxForwardDistance)
                  finalOffset = Vector3.new(0, 0, forwardDistance)

                  if forwardDistance >= maxForwardDistance then
                      gojoConnection:Disconnect()
                      player.Character:BreakJoints()
                  end
              end
          end

          -- Calculate rotated offset
          local rotatedOffset = targetCFrame.RightVector * finalOffset.X + 
                                 targetCFrame.UpVector * finalOffset.Y + 
                                 targetCFrame.LookVector * finalOffset.Z
          
          -- Calculate the exact desired position
          local desiredPosition = targetCFrame.Position + rotatedOffset
          
          -- Set the bot's position precisely
          localHumanoidRootPart.CFrame = CFrame.new(desiredPosition) * 
                                         targetCFrame.Rotation
          
          -- Remove velocity to prevent drifting
          removeVelocity()

          -- Disconnect if middle is reached for bot1 and bot3
          if middleReached and (botIndex == 1 or botIndex == 3) then
              gojoConnection:Disconnect()
          end
      else
          gojoConnection:Disconnect()
      end
  end)

  return gojoConnection
end

-- ;quake
local function quake(targetPlayer, radius)
  -- Stop any existing quake connection
  if quakeConnection then
      quakeConnection:Disconnect()
      quakeConnection = nil
  end

  radius = radius or 30   -- Default radius

  if not targetPlayer or not targetPlayer.Character then
      return nil
  end
  
  local targetHumanoidRootPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
  if not targetHumanoidRootPart then
      return nil
  end

  local humanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
  local humanoid = player.Character:FindFirstChild("Humanoid")
  
  -- Set quake boolean to true
  quakebool = true

  if humanoidRootPart and humanoid then
      -- Randomize teleport position
      local function getRandomPosition()
          local randomAngle = math.random() * 2 * math.pi
          local randomRadius = math.random(radius/2, radius)  -- Randomize within specified radius
          
          local offsetX = math.cos(randomAngle) * randomRadius
          local offsetZ = math.sin(randomAngle) * randomRadius
          
          local newPosition = targetHumanoidRootPart.Position + Vector3.new(offsetX, -0, offsetZ)
          
          return newPosition
      end
      
      -- Continuously update position and rotation
      quakeConnection = RunService.Heartbeat:Connect(function()
          -- Check if quake should continue
          if not quakebool or not player or not player.Character then
              if quakeConnection then
                  quakeConnection:Disconnect()
                  quakeConnection = nil
              end
              return
          end

          if humanoidRootPart and humanoidRootPart.Parent then
              humanoidRootPart.Velocity = Vector3.new(0, 0, 0)
              humanoid:ChangeState(Enum.HumanoidStateType.Physics)
              
              -- Continuously teleport to a new random position near the target
              local newPosition = getRandomPosition()
              
              -- Create a CFrame that looks at the target while maintaining the new position
              local newCFrame = CFrame.new(newPosition, targetHumanoidRootPart.Position)
              
              humanoidRootPart.CFrame = newCFrame
              
              wait(1)  -- Small delay between teleports
          else
              -- Cleanup if character is destroyed
              if quakeConnection then
                  quakeConnection:Disconnect()
                  quakeConnection = nil
              end
          end
      end)

      return quakeConnection
  end

  return nil
end

-- ;mine 
local function mine(targetPlayer)
  -- Add a bool for the mine command
  minebool = true

  if not targetPlayer then
      -- If no target player is specified, just teleport underground
      local humanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
      local humanoid = player.Character:FindFirstChild("Humanoid")
      
      if humanoidRootPart and humanoid then
          -- Prevent falling animation by setting humanoid state
          humanoid:ChangeState(Enum.HumanoidStateType.Physics)
          
          -- Teleport underground at current location
          local newPosition = humanoidRootPart.Position + Vector3.new(0, -4.2, 0)
          
          -- Create a CFrame at the underground position
          local newCFrame = CFrame.new(newPosition)
          
          -- Teleport and lock the bot in place
          humanoidRootPart.CFrame = newCFrame
          
          -- Continuous position maintenance
          local connection
          connection = RunService.Heartbeat:Connect(function()
              if not minebool then
                  connection:Disconnect()
                  return
              end
              
              if humanoidRootPart and humanoidRootPart.Parent then
                  -- Zero out velocity
                  humanoidRootPart.Velocity = Vector3.new(0, 0, 0)
                  
                  -- Ensure physics state
                  humanoid:ChangeState(Enum.HumanoidStateType.Physics)
                  
                  -- Maintain the exact underground position
                  humanoidRootPart.CFrame = newCFrame
              else
                  -- Cleanup if character is destroyed
                  if connection then
                      connection:Disconnect()
                  end
              end
          end)
          
          return connection
      end
  else
      if not targetPlayer.Character then
          return
      end
      
      local targetHumanoidRootPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
      if not targetHumanoidRootPart then
          return
      end

      local humanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
      local humanoid = player.Character:FindFirstChild("Humanoid")
      
      if humanoidRootPart and humanoid then
          -- Prevent falling animation by setting humanoid state
          humanoid:ChangeState(Enum.HumanoidStateType.Physics)
          
          -- Single teleport function
          local function getTeleportPosition()
              local randomAngle = math.random() * 2 * math.pi
              local randomRadius = math.random(5, 15)  -- Between 5 and 15 studs
              
              local offsetX = math.cos(randomAngle) * randomRadius
              local offsetZ = math.sin(randomAngle) * randomRadius
              
              -- Teleport deeper underground
              local newPosition = targetHumanoidRootPart.Position + Vector3.new(offsetX, -4.2, offsetZ)
              
              return newPosition
          end
          
          -- Initial teleport
          local newPosition = getTeleportPosition()
          
          -- Create a CFrame at the underground position (removed looking at target)
          local newCFrame = CFrame.new(newPosition)
          
          -- Teleport and lock the bot in place
          humanoidRootPart.CFrame = newCFrame
          
          -- Continuous position maintenance
          local connection
          connection = RunService.Heartbeat:Connect(function()
              if not minebool then
                  connection:Disconnect()
                  return
              end
              
              if humanoidRootPart and humanoidRootPart.Parent then
                  -- Zero out velocity
                  humanoidRootPart.Velocity = Vector3.new(0, 0, 0)
                  
                  -- Ensure physics state
                  humanoid:ChangeState(Enum.HumanoidStateType.Physics)
                  
                  -- Maintain the exact underground position
                  humanoidRootPart.CFrame = newCFrame
              else
                  -- Cleanup if character is destroyed
                  if connection then
                      connection:Disconnect()
                  end
              end
          end)
          
          return connection
      end
  end
end

-- ;elevator
local function elevator(targetPlayer)
  -- Get the bot's index to determine position
  local displayName = player.DisplayName
  local botIndex = table.find(bots, displayName)
  if not botIndex then return end

  -- Calculate initial position
  local totalBots = #bots
  local middleOffset = math.floor(totalBots / 2)
  local horizontalOffset = (botIndex - middleOffset - 1) * 3

  -- Reset any existing elevator command
  if elevatorbool then
    elevatorbool = false
  end
  elevatorbool = true
  
  -- Get initial target position
  local initialPosition
  if targetPlayer and targetPlayer.Character then
    local targetHumanoidRootPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
    if targetHumanoidRootPart then
      initialPosition = targetHumanoidRootPart.Position
    end
  end

  if not initialPosition then return end
  
  -- Start rising motion
  local startTime = tick()
  local riseConnection
  riseConnection = RunService.Heartbeat:Connect(function()
    if not elevatorbool or commandInProgress ~= "elevator" then
      riseConnection:Disconnect()
      return
    end

    if not player or not player.Character then
      riseConnection:Disconnect()
      return
    end

    local humanoid = player.Character:FindFirstChild("Humanoid")
    if not humanoid or humanoid.Health <= 0 then
      riseConnection:Disconnect()
      return
    end

    local localHumanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
    if localHumanoidRootPart then
      -- Calculate rising height based on time since start
      local timePassed = tick() - startTime
      local height = math.max(-3 + timePassed * 2, -3) -- Start at -3 and rise up
      
      -- Position with horizontal offset and rising height
      local offset = Vector3.new(horizontalOffset, height, 0)
      local rotation = CFrame.Angles(math.rad(90), 0, 0)
      localHumanoidRootPart.CFrame = CFrame.new(initialPosition + offset) * rotation
      
      removeVelocity()
    end
  end)
  
  commandInProgress = "elevator"
end

-- ;unelevator
local function unelevator()
  elevatorbool = false
end

-- ;sword
local function sword(targetPlayer, initialDistance)
  -- Stop any existing sword connection
  if swordConnection then
      swordConnection:Disconnect()
      swordConnection = nil
  end

  if not targetPlayer or not targetPlayer.Character then
      return nil
  end

  local targetHumanoidRootPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
  if not targetHumanoidRootPart then
      return nil
  end

  -- Set sword boolean to true
  swordbool = true
  
  -- Get the bot's index to determine position
  local displayName = player.DisplayName
  local botIndex = table.find(bots, displayName)

  if not botIndex then 
      return nil
  end

  -- Dynamic distance calculation
  local subsequentSpacing = 5 -- Spacing between subsequent bots

  -- Calculate the bot's specific distance
  local forwardDistance
  if botIndex == 1 then
      forwardDistance = initialDistance  -- Use the initial distance specified
  else
      -- Subsequent bots are placed incrementally further
      forwardDistance = initialDistance + ((botIndex - 1) * subsequentSpacing)
  end

  -- Continuous positioning mechanism
  swordConnection = RunService.Heartbeat:Connect(function()
      -- Check if sword should continue
      if not swordbool or not player or not player.Character then
          if swordConnection then
              swordConnection:Disconnect()
              swordConnection = nil
          end
          return
      end

      local localHumanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
      local localHumanoid = player.Character:FindFirstChild("Humanoid")

      if localHumanoidRootPart and targetHumanoidRootPart and localHumanoid then
          -- Get target's current position and rotation
          local targetCFrame = targetHumanoidRootPart.CFrame

          -- Calculate forward vector
          local forwardVector = targetCFrame.LookVector * forwardDistance

          -- Compute final position
          local desiredPosition = targetCFrame.Position + forwardVector

          -- Rotate 90 degrees to make the bot's face point towards the sky
          local rotatedCFrame = CFrame.lookAt(desiredPosition, targetCFrame.Position) * CFrame.Angles(math.rad(90), 0, 0)

          -- Set bot's CFrame to always face the target player but rotated upward
          localHumanoidRootPart.CFrame = rotatedCFrame

          -- Add velocity towards the target
          local velocityDirection = (targetHumanoidRootPart.Position - localHumanoidRootPart.Position).Unit
          local velocityMagnitude = -500  -- Adjust this value to control speed
          
          localHumanoidRootPart.Velocity = velocityDirection * velocityMagnitude
          
          -- Optional: Add some vertical velocity
          localHumanoidRootPart.Velocity = localHumanoidRootPart.Velocity + Vector3.new(0, 0, 0)
      else
          -- Disconnect if target or bot is missing
          if swordConnection then
              swordConnection:Disconnect()
              swordConnection = nil
          end
      end
  end)

  return swordConnection
end

-- ;shotgun
local function shotgun(targetPlayer, initialDistance)
  -- Stop any existing shotgun connection
  if shotgunConnection then
      shotgunConnection:Disconnect()
      shotgunConnection = nil
  end

  if not targetPlayer or not targetPlayer.Character then
      return nil
  end

  local targetHumanoidRootPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
  if not targetHumanoidRootPart then
      return nil
  end

  -- Set shotgun boolean to true
  shotgunbool = true
  
  -- Get the bot's index to determine position
  local displayName = player.DisplayName
  local botIndex = table.find(bots, displayName)

  if not botIndex then 
      return nil
  end

  -- Dynamic distance calculation
  local subsequentSpacing = 2.5 -- Spacing between subsequent bots

  -- Calculate the bot's specific distance
  local forwardDistance
  if botIndex == 1 then
      forwardDistance = initialDistance  -- Use the initial distance specified
  else
      -- Subsequent bots are placed incrementally further
      forwardDistance = initialDistance + ((botIndex - 1) * subsequentSpacing)
  end

  -- Store initial velocity
  local initialVelocity = Vector3.new(0, 0, 0)
  local velocityTimer = nil
  local stateChangeTimer = nil
  local sitTimer = nil
  local unsitTimer = nil
  local velocityEnabled = false  -- New flag to control velocity

  -- Continuous positioning mechanism
  shotgunConnection = RunService.Heartbeat:Connect(function()
      -- Check if shotgun should continue
      if not shotgunbool or not player or not player.Character then
          if shotgunConnection then
              shotgunConnection:Disconnect()
              shotgunConnection = nil
          end
          return
      end

      local localHumanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
      local localHumanoid = player.Character:FindFirstChild("Humanoid")

      if localHumanoidRootPart and targetHumanoidRootPart and localHumanoid then
          -- Get target's current position and rotation
          local targetCFrame = targetHumanoidRootPart.CFrame

          -- Calculate forward vector
          local forwardVector = targetCFrame.LookVector * forwardDistance

          -- Compute final position
          local desiredPosition = targetCFrame.Position + forwardVector

          -- Rotate 90 degrees to make the bot's face point towards the sky
          local rotatedCFrame = CFrame.lookAt(desiredPosition, targetCFrame.Position) * CFrame.Angles(math.rad(90), 0, 0)

          -- Set bot's CFrame to always face the target player but rotated upward
          localHumanoidRootPart.CFrame = rotatedCFrame

          -- Add velocity towards the target only when enabled
          local velocityDirection = (targetHumanoidRootPart.Position - localHumanoidRootPart.Position).Unit
          local velocityMagnitude = -400  -- Adjust this value to control speed
          
          -- Only apply velocity when flag is true
          if velocityEnabled then
              local currentVelocity = velocityDirection * velocityMagnitude
              localHumanoidRootPart.Velocity = currentVelocity
              
              -- Store initial velocity for reset timer
              if initialVelocity.Magnitude == 0 then
                  initialVelocity = currentVelocity
              end
          else
              -- Ensure no velocity when not enabled
              localHumanoidRootPart.Velocity = Vector3.new(0, 0, 0)
          end

          -- Timer to reset character while maintaining velocity
          if not velocityTimer then
              velocityTimer = task.delay(3, function()
                  -- Reset character
                  player.Character:BreakJoints()
                  
                  -- Immediately end the shotgun process when bones break
                  shotgunbool = false
                  if shotgunConnection then
                      shotgunConnection:Disconnect()
                      shotgunConnection = nil
                  end
              end)
          end

          -- Add timer to sit the player after 2 seconds
          if not sitTimer then
              sitTimer = task.delay(2, function()
                  sit()
              end)
          end

          -- Add timer to change Humanoid state to Seated after 2 seconds
          if not stateChangeTimer then
              stateChangeTimer = task.delay(2, function()
                  if localHumanoid then
                      localHumanoid:ChangeState(Enum.HumanoidStateType.Seated)
                  end
              end)
          end

          -- Add timer to unsit the player and enable velocity after 2.5 seconds
          if not unsitTimer then
              unsitTimer = task.delay(2.5, function()
                  if localHumanoid then
                      localHumanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
                      velocityEnabled = true  -- Enable velocity at 2.7 seconds
                  end
              end)
          end
      else
          -- Disconnect if target or bot is missing
          if shotgunConnection then
              shotgunConnection:Disconnect()
              shotgunConnection = nil
          end
      end
  end)

  return shotgunConnection
end

-- ;bridge
local function bridge(targetPlayer)
  -- Stop any existing bridge connection
  if bridgeConnection then
      bridgeConnection:Disconnect()
      bridgeConnection = nil
  end

  if not targetPlayer or not targetPlayer.Character then
      return nil
  end

  local targetHumanoidRootPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
  if not targetHumanoidRootPart then
      return nil
  end

  -- Set bridge boolean to true
  bridgebool = true
  
  -- Get the bot's index to determine position
  local displayName = player.DisplayName
  local botIndex = table.find(bots, displayName)

  if not botIndex then 
      return nil
  end

  -- Dynamic forward distance calculation
  local baseForwardDistance = 2.5 -- Starting distance
  local forwardDistance = baseForwardDistance * (botIndex * 2)  -- Increases by 3 for each bot

  -- Continuous positioning mechanism
  bridgeConnection = RunService.Heartbeat:Connect(function()
      -- Check if bridge should continue
      if not bridgebool or not player or not player.Character then
          if bridgeConnection then
              bridgeConnection:Disconnect()
              bridgeConnection = nil
          end
          return
      end

      local localHumanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
      local localHumanoid = player.Character:FindFirstChild("Humanoid")

      if localHumanoidRootPart and targetHumanoidRootPart and localHumanoid then
          -- Get target's current position and rotation
          local targetCFrame = targetHumanoidRootPart.CFrame

          -- Calculate forward vector
          local forwardVector = targetCFrame.LookVector * forwardDistance

          -- Compute final position
          local desiredPosition = targetCFrame.Position + forwardVector

          -- Rotate 90 degrees to make the bot's face point towards the sky
          local rotatedCFrame = CFrame.lookAt(desiredPosition, targetCFrame.Position) * CFrame.Angles(math.rad(90), 0, 0)

          -- Set bot's CFrame to always face the target player but rotated upward
          localHumanoidRootPart.CFrame = rotatedCFrame

          -- Remove velocity to prevent drifting
          removeVelocity()
      else
          -- Disconnect if target or bot is missing
          if bridgeConnection then
              bridgeConnection:Disconnect()
              bridgeConnection = nil
          end
      end
  end)

  return bridgeConnection
end

-- ;unbridge
local function unbridge()
  -- Disconnect the bridge connection if it exists
  if bridgeConnection then
      bridgeConnection:Disconnect()
      bridgeConnection = nil
  end
end

-- ;tower
local function tower(targetPlayer)
  if not targetPlayer or not targetPlayer.Character then

      return
  end

  local targetHumanoidRootPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
  if not targetHumanoidRootPart then
      return
  end

  towerbool = true

  local heartbeatConnection
  heartbeatConnection = RunService.Heartbeat:Connect(function()
      if not towerbool or not targetHumanoidRootPart or not targetPlayer.Character then
          heartbeatConnection:Disconnect()
          return
      end

      if player and player.Character then
          local localHumanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
          if localHumanoidRootPart then
              local offset = targetHumanoidRootPart.CFrame.UpVector * 5 * index
              localHumanoidRootPart.CFrame = targetHumanoidRootPart.CFrame + offset

              removeVelocity()
          end
      end
  end)
end

-- ;follow
local function followPlayer(targetPlayer)
  if targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
    while followbool and targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") do
      local humanoidRootPart = targetPlayer.Character.HumanoidRootPart
      player.Character.Humanoid:MoveTo(humanoidRootPart.Position)
      wait(0.1)
    end
  else
    warn("Target player or their character is not valid.")
  end
end

-- ;spin from IY
local function spin(spinSpeed)
  local character = player.Character or player.CharacterAdded:Wait()

  local root = character:FindFirstChild("HumanoidRootPart")

  if root then
    local existingSpin = root:FindFirstChild("Spinning")
    if existingSpin then
      existingSpin:Destroy()
    end

    local Spin = Instance.new("BodyAngularVelocity")
    Spin.Name = "Spinning"
    Spin.Parent = root
    Spin.MaxTorque = Vector3.new(0, math.huge, 0)
    Spin.AngularVelocity = Vector3.new(0, spinSpeed, 0)

    while boolspin do
      wait(0.1)
    end

    Spin:Destroy()
  end
end

-- ;worm
local function worm(msgtarget2)
  local displayName = player.DisplayName
  local indexworm = table.find(bots, displayName)

  if not indexworm then
    return
  end

  if indexworm > 1 then
    local targetBotName = bots[indexworm - 1]
    local targetPlayer = findPlayerByName(targetBotName)
    if targetPlayer then
      wormbool = true

      while  wormbool and targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") do
        local humanoidRootPart = targetPlayer.Character.HumanoidRootPart
        player.Character.Humanoid:MoveTo(humanoidRootPart.Position)
        wait(0.1)
      end
    else
    end
  else

    if msgtarget2 and msgtarget2.Character and msgtarget2.Character:FindFirstChild("HumanoidRootPart") then
      followbool = true
      while followbool and msgtarget2 and msgtarget2.Character and msgtarget2.Character:FindFirstChild("HumanoidRootPart") do
        local humanoidRootPart = msgtarget2.Character.HumanoidRootPart
        player.Character.Humanoid:MoveTo(humanoidRootPart.Position)
        wait(0.1)
      end
    else
    end
  end
end

-- ;orbit from IY but modified
local function orbitPlayer(targetPlayer, speed, r)
  game.Workspace.Gravity = 0

  if r == 0 then
    r = 0.0001
  end

  local playerCharacter = player.Character
  local playerHumanoidRootPart = playerCharacter and playerCharacter:FindFirstChild("HumanoidRootPart")

  if not playerHumanoidRootPart then
    return
  end

  local targetHumanoidRootPart = targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart")
  if not targetHumanoidRootPart then
    return
  end

  local rotation = indexcircle
  local orbitConnection
  orbitConnection = RunService.Heartbeat:Connect(function()
  if not orbitbool or not targetPlayer or not targetPlayer.Character or not targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
    orbitConnection:Disconnect()
    return
  end

  removeVelocity()
  local newCFrame = CFrame.new(targetHumanoidRootPart.Position)
  * CFrame.Angles(0, math.rad(rotation), 0) -- if you are bored try to mess with values
  * CFrame.new(r, 0, 0)
  playerHumanoidRootPart.CFrame = newCFrame
  local lookAtCFrame = CFrame.new(playerHumanoidRootPart.Position, targetHumanoidRootPart.Position)
  playerHumanoidRootPart.CFrame = lookAtCFrame
  rotation = (rotation + speed) % 360
  end)
end

-- ;orbit2
local function orbitPlayer2(targetPlayer, speed, r)
  game.Workspace.Gravity = 0

  if r == 0 then
    r = 0.0001
  end

  local playerCharacter = player.Character
  local playerHumanoidRootPart = playerCharacter and playerCharacter:FindFirstChild("HumanoidRootPart")

  if not playerHumanoidRootPart then
    return
  end

  local targetHumanoidRootPart = targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart")
  if not targetHumanoidRootPart then
    return
  end

  local rotation = indexcircle
  local orbitConnection
  orbitConnection = RunService.Heartbeat:Connect(function()
  if not orbitbool2 or not targetPlayer or not targetPlayer.Character or not targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
    orbitConnection:Disconnect()
    return
  end

  removeVelocity()
  local newCFrame = CFrame.new(targetHumanoidRootPart.Position)
  * CFrame.Angles(math.rad(rotation), math.rad(rotation), 0)
  * CFrame.new(r, 0, 0)
  playerHumanoidRootPart.CFrame = newCFrame
  local lookAtCFrame = CFrame.new(playerHumanoidRootPart.Position, targetHumanoidRootPart.Position)
  playerHumanoidRootPart.CFrame = lookAtCFrame
  rotation = (rotation + speed) % 360
  end)
end

-- ;orbit3
local function orbitPlayer3(targetPlayer, speed, r)
  game.Workspace.Gravity = 0

  if r == 0 then
    r = 0.0001
  end

  local playerCharacter = player.Character
  local playerHumanoidRootPart = playerCharacter and playerCharacter:FindFirstChild("HumanoidRootPart")

  if not playerHumanoidRootPart then
    return
  end

  local targetHumanoidRootPart = targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart")
  if not targetHumanoidRootPart then
    return
  end

  local rotation = indexcircle
  local orbitConnection
  orbitConnection = RunService.Heartbeat:Connect(function()
  if not orbitbool3 or not targetPlayer or not targetPlayer.Character or not targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
    orbitConnection:Disconnect()
    return
  end

  removeVelocity()
  local newCFrame = CFrame.new(targetHumanoidRootPart.Position)
  * CFrame.Angles(0, math.rad(rotation), 90) -- if you are bored try to mess with values
  * CFrame.new(r, 0, 0)
  playerHumanoidRootPart.CFrame = newCFrame
  local lookAtCFrame = CFrame.new(playerHumanoidRootPart.Position, targetHumanoidRootPart.Position)
  playerHumanoidRootPart.CFrame = lookAtCFrame
  rotation = (rotation + speed) % 360
  end)
end

-- ;orbit4
local function orbitPlayer4(targetPlayer, speed, r)
  game.Workspace.Gravity = 0

  if r == 0 then
    r = 0.0001
  end

  local playerCharacter = player.Character
  local playerHumanoidRootPart = playerCharacter and playerCharacter:FindFirstChild("HumanoidRootPart")

  if not playerHumanoidRootPart then
    return
  end

  local targetHumanoidRootPart = targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart")
  if not targetHumanoidRootPart then
    return
  end

  removeVelocity()
  local rotation = indexcircle
  local orbitConnection
  orbitConnection = RunService.Heartbeat:Connect(function()
  if not orbitbool4 or not targetPlayer or not targetPlayer.Character or not targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
    orbitConnection:Disconnect()
    return
  end

  local newCFrame = CFrame.new(targetHumanoidRootPart.Position)
  * CFrame.Angles(math.rad(rotation),0, math.rad(rotation))
  * CFrame.new(r, 0, 0)
  playerHumanoidRootPart.CFrame = newCFrame
  local lookAtCFrame = CFrame.new(playerHumanoidRootPart.Position, targetHumanoidRootPart.Position)
  playerHumanoidRootPart.CFrame = lookAtCFrame
  rotation = (rotation + speed) % 360
  end)
end

-- ;orbit5
local function orbitPlayer5(targetPlayer, speed, r)
  game.Workspace.Gravity = 0

  if r == 0 then
    r = 0.0001
  end

  local playerCharacter = player.Character
  local playerHumanoidRootPart = playerCharacter and playerCharacter:FindFirstChild("HumanoidRootPart")

  if not playerHumanoidRootPart then
    return
  end

  local targetHumanoidRootPart = targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart")
  if not targetHumanoidRootPart then
    return
  end

  local rotation = indexcircle
  local orbitConnection
  orbitConnection = RunService.Heartbeat:Connect(function()
  if not orbitbool5 or not targetPlayer or not targetPlayer.Character or not targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
    orbitConnection:Disconnect()
    return
  end

  removeVelocity()
  local newCFrame = CFrame.new(targetHumanoidRootPart.Position)
  * CFrame.Angles(math.rad(math.random(0, 360)), math.rad(math.random(0, 360)), math.rad(math.random(0, 360)))
  * CFrame.new(r, 0, 0)
  playerHumanoidRootPart.CFrame = newCFrame
  local lookAtCFrame = CFrame.new(playerHumanoidRootPart.Position, targetHumanoidRootPart.Position)
  playerHumanoidRootPart.CFrame = lookAtCFrame
  rotation = (rotation + speed) % 360
  end)
end

-- ;orbit6
local function orbitPlayer6(targetPlayer, speed, r)
  game.Workspace.Gravity = 0

  if r == 0 then
    r = 0.0001
  end

  local playerCharacter = player.Character
  local playerHumanoidRootPart = playerCharacter and playerCharacter:FindFirstChild("HumanoidRootPart")

  if not playerHumanoidRootPart then
    return
  end

  local targetHumanoidRootPart = targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart")
  if not targetHumanoidRootPart then
    return
  end

  local rotation = indexcircle
  local orbitConnection
  orbitConnection = RunService.Heartbeat:Connect(function()
  if not orbitbool6 or not targetPlayer or not targetPlayer.Character or not targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
    orbitConnection:Disconnect()
    return
  end

  removeVelocity()
  local newCFrame = CFrame.new(targetHumanoidRootPart.Position)
  * CFrame.Angles(math.rad(math.random(0, 360)), math.rad(math.random(0, 360)), 0)
  * CFrame.new(r, 0, 0)
  playerHumanoidRootPart.CFrame = newCFrame
  local lookAtCFrame = CFrame.new(playerHumanoidRootPart.Position, targetHumanoidRootPart.Position)
  playerHumanoidRootPart.CFrame = lookAtCFrame
  rotation = (rotation + speed) % 360
  end)
end

-- ;stalk
local function stalkPlayer(targetPlayer)
  if targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
    while stalkbool and targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") do
      local humanoidRootPart = targetPlayer.Character.HumanoidRootPart
      local botHumanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")

      if botHumanoidRootPart then
        local distance = (botHumanoidRootPart.Position - humanoidRootPart.Position).Magnitude

        if distance > 25 then --make them tp if they are too far from the player, otherwise the cmd would be useless
          botHumanoidRootPart.CFrame = humanoidRootPart.CFrame + humanoidRootPart.CFrame.LookVector * -2.06546464
        else
          local randomOffset = Vector3.new(math.random(-8, 8),0,math.random(-8, 8))
          local moveToPosition = humanoidRootPart.Position + randomOffset
          player.Character.Humanoid:MoveTo(moveToPosition)
        end
      end
      wait(0.28) -- small delay otherwise it looks like they're having an seizure
    end
  else
    warn("Target player or their character is not valid.")
  end
end

-- check chat for cmds
local function connectChatListener(playerpower)
  playerpower.Chatted:Connect(function(message)
  if playerpower.Name == owner or table.find(Admins, playerpower.Name) then
    if message:sub(1, #prefix) == prefix then
      local command = message:sub(#prefix + 1)
      if command == "status" and cmdstatus and table.find(bots, displayName) then
        chatMessage(displayName .. " (Bot " .. index .. ") is active!")
        wait(2)

      elseif command:sub(1, 6) == "admin " and table.find(bots, displayName) and cmdadmin then
        -- Only allow the owner to use admin command
        if playerpower.Name == owner then
            local adminargs = command:sub(7)
            local targetPlayerforadmin = findPlayerByName(adminargs)
        
            if targetPlayerforadmin then
                -- Check if the player is not already an admin
                if not table.find(Admins, targetPlayerforadmin.Name) then
                    table.insert(Admins, targetPlayerforadmin.Name)
                    table.insert(adminNotConnected, targetPlayerforadmin.Name)
                    
                    -- Immediately connect chat listener if the player is currently in the game
                    local existingPlayer = game.Players:FindFirstChild(targetPlayerforadmin.Name)
                    if existingPlayer then
                        connectChatListener(existingPlayer)
                    end
                    
                    if index == 1 then
                        chatMessage(targetPlayerforadmin.Name .. ' is now an admin.')
                        wait(1)
                        chatMessage("Type ;cmds for a list of commands")
                    end
                else
                    if index == 1 then
                        chatMessage(targetPlayerforadmin.Name .. ' is already an admin.')
                    end
                end
            else
                if index == 1 then
                    chatMessage("Player not found.")
                end
            end
        else
            -- Deny access for non-owner
            if index == 1 then
                chatMessage("Only the owner can use this command.")
            end
        end
        wait(2)
    
    elseif command:sub(1, 8) == "unadmin " and table.find(bots, displayName) and cmdunadmin then
        -- Only allow the owner to use unadmin command
        if playerpower.Name == owner then
            local unadminargs = command:sub(9)
            local targetPlayerforunadmin = findPlayerByName(unadminargs)
        
            if targetPlayerforunadmin then
                -- Check if the player is currently an admin
                local adminIndex = table.find(Admins, targetPlayerforunadmin.Name)
                if adminIndex then
                    table.remove(Admins, adminIndex)
                    
                    local notConnectedIndex = table.find(adminNotConnected, targetPlayerforunadmin.Name)
                    if notConnectedIndex then
                        table.remove(adminNotConnected, notConnectedIndex)
                    end
                    
                    if index == 1 then
                        chatMessage(targetPlayerforunadmin.Name .. ' is no longer an admin.')
                    end
                else
                    if index == 1 then
                        chatMessage(targetPlayerforunadmin.Name .. ' is not an admin.')
                    end
                end
            else
                if index == 1 then
                    chatMessage("Player not found.")
                end
            end
        else
            -- Deny access for non-owner
            if index == 1 then
                chatMessage("Only the owner can use this command.")
            end
        end
        wait(2)
    
    elseif command == "quit" and table.find(bots, displayName) and cmdquit then
        -- Only allow the owner to use quit command | Important
        if playerpower.Name == owner then
            cmdstatus = false
            cmdindex = false
            cmdfollow = false
            cmdquit = false
            cmddance = false
            cmdundance = false
            cmdreset = false
            cmdjump = false
            cmdsay = false
            cmdunfollow = false
            followbool = false
            cmdreset = false
            cmdorbit = false
            orbitbool = false
            cmdunorbit = false
            cmdgoto = false
            cmdalign = false
            cmdws = false
            booljump = false
            cmdloopjump = false
            cmdunloopjump = false
            cmdcircle = false
            cmdchannel = false
            orbitbool = false
            orbitbool5 = false
            orbitbool2 = false
            orbitbool3 = false
            orbitbool4 = false
            orbitbool6 = false
            wormbool = false
            cmdworm = false
            cmdunworm = false
            cmdspin = false
            cmdunspin = false
            boolspin = false
            cmdadmin = false
            adminbool = false
            cmdarch = false
            cmdorbit2 = false
            cmdorbit3 = false
            cmdorbit4 = false
            cmdorbit5 = false
            cmdorbit6 = false
            cmdstalk = false
            stalkbool = false
            cmdunstalk = false
            cmdcmds = false
            towerbool = false
            cmdtower = false
            cmduntower = false
            cmdfix = false
            cmdfling = false
            flingbool = false
            cmdexplode = false
            cmdelevator = false
            elevatorbool = false
            gojobool = false
            cmdbridge = false
            bridgebool = false
            cmdgojo = false
            cmdunbridge = false
            cmdfireworks = false
            cmdnuke = false
            cmdgravity = false
            cmdsit = false
            cmdladder = false
            ladderbool = false
            minebool = false
            cmdmine = false
            cmdragdoll = false
            cmdunragdoll = false
            cmdquake = false
            quakebool = false
            cmdsword = false
            cmdunsword = false
            swordbool = false
            cmdshotgun = false
            cmdunshotgun = false
            shotgunbool = false
            Admins = {}
            adminNotConnected = {}
            chatMessage("Ended Script.")
            wait(2)
        else
            -- Deny access for non-owner
            if index == 1 then
                chatMessage("Only the owner can use this command.")
            end
        end

      elseif command == "index" and cmdindex and table.find(bots, displayName) then
        chatMessage(displayName .. " index is (" .. index .. ")")
        wait(2)

      elseif command:sub(1, 8) == "channel " and cmdchannel and table.find(bots, displayName) then
        local chnl = tonumber(command:sub(9))

        if chnl > nbbot or chnl < 1 then
          if index == channel then
            chatMessage("Error: channel must be between 1 and " .. nbbot)
          end
        else
          channel = chnl
          if index == channel then
            chatMessage("Channel is now: " .. channel)
          end
        end
        wait(2)

      elseif command:sub(1, 15) == "unloopjump" and cmdunloopjump and table.find(bots, displayName) then
        booljump = false
        wait(2)
      
      elseif command:sub(1, 8) == "untower" and cmduntower and table.find(bots, displayName) then
          towerbool = false
          wait(2)

      elseif command == "loopjump" and cmdloopjump and table.find(bots, displayName) then
        booljump = true
        while booljump do
          player.Character.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
          wait(0.8)
        end
        wait(2)

      elseif command:sub(1, 5) == "left " and cmdleft and table.find(bots, displayName) then
        disablebool()
        local playerName = command:sub(6)
        local targetPlayer = findPlayerByName(playerName)
        if targetPlayer then
          left(targetPlayer)
          wait(2)
        end

      elseif command:sub(1, 6) == "right " and cmdright and table.find(bots, displayName) then
        local playerName = command:sub(7)
        local targetPlayer = findPlayerByName(playerName)
        if targetPlayer then
          right(targetPlayer)
          wait(2)
        end

      elseif command:sub(1, 7) == "dance" and table.find(bots, displayName) and cmddance then
        chatMessage("/e dance")
        wait(2)

      elseif command:sub(1, 7) == "dance 1" and table.find(bots, displayName) and cmddance then
        chatMessage("/e dance1")
        wait(2)

      elseif command:sub(1, 7) == "dance 2" and table.find(bots, displayName) and cmddance then
        chatMessage("/e dance2")
        wait(2)

      elseif command:sub(1, 7) == "dance 3" and table.find(bots, displayName) and cmddance then
        chatMessage("/e dance3")
        wait(2)

      elseif command:sub(1, 7) == "dance 4" and table.find(bots, displayName) and cmddance then
        chatMessage("/e dance 4")
        wait(2)
      
      elseif command:sub(1, 5) == "cmds" and table.find(bots, displayName) and cmdcmds then
        if index == 1 then
            chatMessage(";status ;index ;follow [plr] ;quit ;dance <number> ;undance ;reset ;jump ;say <sentence> ;unfollow ;orbit [plr] <radius> <speed>")
            chatMessage(";orbit2 [plr] <radius> <speed> ;orbit3 [plr] <radius> <speed> ;orbit4 [plr] <radius> <speed> ;orbit5 [plr] <radius> <speed>")
            chatMessage(";orbit6 [plr] <radius> <speed> ;unorbit ;goto [plr] ;ws <number> ;loopjump ;unloopjump ;circle <number> ;channel <number>")
            chatMessage(";worm [plr] ;unworm ;spin <number> ;unspin ;admin [plr] ;arch <number> ;stalk [plr] ;unstalk ;cmds ;firework")
            chatMessage(";elevator [plr] ;gojo [plr] ;explode [plr] ;fling [plr] ;bridge [plr] ;nuke [plr] ;gravity <number> ;sit ;unsit")
            chatMessage(";ladder (plr) ;ragdoll ;unragdoll ;sword [plr] <distance> ;unsword ;shotgun [plr] <distance> ;unshotgun")
        end
        wait(2)

      elseif command:sub(1, 5) == "spin " and table.find(bots, displayName) and cmdspin then
        local spinarg = tonumber(command:sub(6))
        spin(spinarg)
        boolspin = true
        wait(2)

      elseif command:sub(1, 8) == "ragdoll" and table.find(bots, displayName) and cmdragdoll then
        ragdoll()
        if index == channel then
            chatMessage("Bots are now ragdolled")
        end
        wait(2)
    
      elseif command:sub(1, 10) == "unragdoll" and table.find(bots, displayName) and cmdunragdoll then
        unragdoll()
        if index == channel then
            chatMessage("Bots are no longer ragdolled")
        end
        wait(2)

      elseif command == "sit" and table.find(bots, displayName) and cmdsit then
        sit()
        if index == channel then
            chatMessage("Bots are now sitting")
        end
        wait(2)
    
    elseif command == "unsit" and table.find(bots, displayName) then
        unsit()
        if index == channel then
            chatMessage("Bots are now standing")
        end
        wait(2)

      elseif command:sub(1, 6) == "unspin" and table.find(bots, displayName) and cmdunspin then
        boolspin = false
        wait(2)

      elseif command:sub(1, 3) == "ws " and table.find(bots, displayName) and cmdws then
        local wsarg = tonumber(command:sub(4))
        if wsarg then
          player.Character.Humanoid.WalkSpeed = wsarg
          wait(2)
        else
        end

      elseif command:sub(1, 7) == "undance" and table.find(bots, displayName) and cmddance then
        player.Character.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        wait(2)

      elseif command:sub(1, 7) == "circle " and table.find(bots, displayName) and cmdcircle then
        disablebool()
        local circlearg = tonumber(command:sub(8)) or 8
        tpcircle(circlearg)
        wait(2)

      elseif command:sub(1, 5) == "arch " and table.find(bots, displayName) and cmdarch then
        disablebool()
        local archarg = tonumber(command:sub(6)) or 8
        tparch(archarg)
        wait(2)

      elseif command:sub(1, 4) == "say " and table.find(bots, displayName) and cmdsay then
        local msgcontent = command:sub(5)
        chatMessage(msgcontent)
        wait(2)

      elseif command:sub(1, 4) == "fix" and table.find(bots, displayName) and cmdfix then
        fix()
        chatmessage("Bot number "..index.."is fixed")
        wait(2)

      elseif command:sub(1, 4) == "jump" and table.find(bots, displayName) and cmdjump then
        player.Character.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        wait(2)

      elseif command:sub(1, 5) == "fling" and table.find(bots, displayName) and cmdfling then
          disablebool()
          local playerName = command:sub(7)
          local targetPlayer = findPlayerByName(playerName)
          if targetPlayer then
            if index == channel then
              chatMessage("Bots are now flinging towards " .. targetPlayer.Name)
            end
            fling(targetPlayer)
            wait(2)
          else
            if index == channel then
              chatMessage("Player not found for flinging.")
            end
          end
        
        elseif command == "unfling" and table.find(bots, displayName) and cmdunfling then
          flingbool = false
          if index == channel then
            chatMessage("Unflinged")
          end
          wait(2)
          
        elseif command:sub(1, 5) == "sword" and table.find(bots, displayName) and cmdsword then
          disablebool()
          local args = command:sub(7):split(" ")  -- Split the command into arguments
          local targetName = args[1]
          local initialDistance = tonumber(args[2]) or 20  -- Default distance is 20 if not specified
      
          local targetPlayer = findPlayerByName(targetName)
      
          if targetPlayer then
              if index == channel then
                  chatMessage("Swording to " .. targetPlayer.Name .. " at a distance of " .. initialDistance)
              end
              sword(targetPlayer, initialDistance)  -- Pass the distance to the sword function
              wait(2)
          else
              if index == channel then
                  chatMessage("Player not found for swording.")
              end
          end

        elseif command:sub(1, 7) == "shotgun" and table.find(bots, displayName) and cmdshotgun then
          disablebool()
          local args = command:sub(9):split(" ")  -- Split the command into arguments
          local targetName = args[1]
          local initialDistance = tonumber(args[2]) or 9  -- Default distance is 20 if not specified
      
          local targetPlayer = findPlayerByName(targetName)
      
          if targetPlayer then
              if index == channel then
                  chatMessage("Shotgunning to " .. targetPlayer.Name .. " at a distance of " .. initialDistance)
              end
              shotgun(targetPlayer, initialDistance)  -- Pass the distance to the shotgun function
              wait(2)
          else
              if index == channel then
                  chatMessage("Player not found for shotgunning.")
              end
          end

        elseif command:sub(1, 9) == "unshotgun" and table.find(bots, displayName) then
          shotgunbool = false
          if shotgunConnection then
              shotgunConnection:Disconnect()
              shotgunConnection = nil
          end
          if index == channel then
              chatMessage("Unshotgunned")
          end
          wait(2)

        elseif command:sub(1, 6) == "bridge" and table.find(bots, displayName) and cmdbridge then
          disablebool()
          local targetName = command:sub(8)
          local targetPlayer = findPlayerByName(targetName)
          
          if targetPlayer then
              if index == channel then
                  chatMessage("Bridging to " .. targetPlayer.Name)
              end
              bridge(targetPlayer)
              wait(2)
          else
              if index == channel then
                  chatMessage("Player not found for bridging.")
              end
          end
      
        elseif command:sub(1, 8) == "unbridge" and table.find(bots, displayName) then
          bridgebool = false
          if bridgeConnection then
              bridgeConnection:Disconnect()
              bridgeConnection = nil
          end
          if index == channel then
              chatMessage("Unbridged")
          end
          wait(2)

      elseif command:sub(1, 5) == "mine " and table.find(bots, displayName) and cmdmine then
        disablebool()
        local playerName = command:sub(6)
        local targetPlayer = findPlayerByName(playerName)
        
        if targetPlayer then
            if index == channel then
                chatMessage("Bots are now mining near " .. targetPlayer.Name)
            end
            mine(targetPlayer)
            wait(2)
        else
            -- If no specific player is mentioned, use default mine behavior
            if index == channel then
                chatMessage("Bots are now mining")
            end
            mine()
            wait(2)
        end

      elseif command == "unmine" and table.find(bots, displayName) and cmdunmine then
        minebool = false
        if index == channel then
            chatMessage("Stopped mining")
        end
        wait(2)

      elseif command:sub(1, 6) == "quake " and table.find(bots, displayName) and cmdquake then
        disablebool()
        local args = command:split(" ")
        local playerName = args[2]
        local radius = tonumber(args[3]) or 30  -- Default radius of 30
        
        local targetPlayer = findPlayerByName(playerName)
        
        if targetPlayer then
            if index == channel then
                chatMessage("Bots are now quaking near " .. targetPlayer.Name .. " (Radius: " .. radius .. ")")
            end
            quake(targetPlayer, radius)
            wait(2)
        else
            -- If no specific player is mentioned, use default quake behavior
            if index == channel then
                chatMessage("Bots are now quaking")
            end
            quake(nil, radius)
            wait(2)
        end

      elseif command:sub(1, 7) == "unquake" and table.find(bots, displayName) and cmdunqake then
        quakebool = false
        if index == channel then
          chatMessage("Stopped quaking")
        end
        wait(2)

      elseif command:sub(1, 5) == "nuke " and table.find(bots, displayName) and cmdnuke then
        disablebool()
        local playerName = command:sub(6)
        local targetPlayer = findPlayerByName(playerName)
        if targetPlayer then
            if index == channel then
                chatMessage("Nuke strike initiated on " .. targetPlayer.Name)
            end
            nuke(targetPlayer)
            wait(2)
        else
            chatMessage("Player not found: " .. playerName)
        end

      elseif command:sub(1, 7) == "gravity" and table.find(bots, displayName) then
        local args = command:split(" ")
        local gravityValue = args[2]

        setGravity(gravityValue)
        wait(2)

      elseif command:sub(1, 5) == "gojo " and table.find(bots, displayName) and cmdgojo then
        disablebool()
        local playerName = command:sub(6)
        local targetPlayer = findPlayerByName(playerName)
        if targetPlayer then
            if index == channel then
                chatMessage("Bots are now in Gojo formation around " .. targetPlayer.Name)
            end
            gojo(targetPlayer)
            wait(2)
        else
            chatMessage("Player not found: " .. playerName)
        end

      elseif command:sub(1, 6) == "ladder" and table.find(bots, displayName) and cmdladder then
        disablebool()
        local playerName = command:sub(8)
        local targetPlayer = findPlayerByName(playerName)
        if targetPlayer then
            if index == channel then
                chatMessage("Creating ladder towards " .. targetPlayer.Name)
            end
            ladder(targetPlayer)
            wait(2)
        else
          chatMessage("Player not found: " .. playerName)
        end
        
      elseif command:sub(1, 9) == "elevator " and table.find(bots, displayName) and cmdelevator then
        disablebool()
        local playerName = command:sub(10)
        local targetPlayer = findPlayerByName(playerName)
        if targetPlayer then
          elevatorbool = true
          elevator(targetPlayer)
        else
          elevator()
        end
        wait(2)

      elseif command:sub(1, 10) == "unelevator" and table.find(bots, displayName) and cmdunelevator then
        unelevator()
        if index == channel then
          chatMessage("Stopped elevator")
        end
        wait(2)

      elseif command:sub(1, 8) == "firework" and table.find(bots, displayName) and cmdfireworks then
        disablebool()
        local playerName = command:sub(10)
        local targetPlayer = findPlayerByName(playerName)
        if command:sub(9,9) == " " and targetPlayer then
          fireworks(targetPlayer)
        else
          fireworks()
        end
        wait(2)

      elseif command:sub(1, 7) == "explode" and table.find(bots, displayName) and cmdexplode then
        disablebool()
        local playerName = command:sub(9)
        local targetPlayer = findPlayerByName(playerName)
        
        if command:sub(8,8) == " " and targetPlayer then
            if index == channel then
                chatMessage("Exploding " .. targetPlayer.Name)
            end
            explode(targetPlayer)
        else
            if index == channel then
                chatMessage("Exploding")
            end
            explode()
        end
        wait(2)

    elseif command:sub(1, 9) == "unorbit" and table.find(bots, displayName) and cmdunorbit then
        orbitbool = false
        orbitbool2 = false
        orbitbool3 = false
        orbitbool4 = false
        orbitbool5 = false
        orbitbool6 = false

        if index == channel then
        end
        game.Workspace.Gravity = 196.2
        wait(2)

    elseif command:sub(1, 5) == "goto " and table.find(bots, displayName) and cmdgoto then
      disablebool()
        local playerName = command:sub(6)
        local targetPlayer = findPlayerByName(playerName)
        if targetPlayer then
          goto(targetPlayer)
          wait(2)
        else
          chatMessage("Player not found: " .. playerName)
        end

    elseif command:sub(1, 6) == "tower " and table.find(bots, displayName) and cmdtower then
      disablebool()
        local playerName = command:sub(7)
        local targetPlayer = findPlayerByName(playerName)
        if targetPlayer then
          tower(targetPlayer)
          wait(2)
        else
          chatMessage("Player not found: " .. playerName)
        end

      elseif command:sub(1, 9) == "unfollow" and table.find(bots, displayName) and cmdunfollow then
        followbool = false
        if index == channel then
          chatMessage("stopped following")
        end
        wait(2)

    elseif command:sub(1, 6) == "unworm" and table.find(bots, displayName) and cmdunworm then
        wormbool = false
        if index == channel then
          chatMessage("stopped worm")
        end
        wait(2)

    elseif command:sub(1, 6) == "orbit " and table.find(bots, displayName) and cmdorbit then
      disablebool()
        orbitbool = false
        local args = command:split(" ")
        local playerName = args[2] 
        local r = tonumber(args[3])
        local speed = tonumber(args[4])

        local targetPlayer = findPlayerByName(playerName)
        if targetPlayer then
          orbitbool = true

          if index == channel then
            chatMessage("Bots are now orbiting " .. targetPlayer.Name)
          end
          orbitPlayer(targetPlayer, speed, r)

          wait(2)
        else
          if index == channel then
            chatMessage("Player not found: " .. playerName)
          end
        end

    elseif command:sub(1, 7) == "orbit2 " and table.find(bots, displayName) and cmdorbit2 then
      disablebool()
        orbitbool2 = false
        local args = command:split(" ")
        local playerName = args[2]
        local r = tonumber(args[3])
        local speed = tonumber(args[4])

        local targetPlayer = findPlayerByName(playerName)
        if targetPlayer then
          orbitbool2 = true 

          if index == channel then
            chatMessage("Bots are now orbiting " .. targetPlayer.Name)
          end
          orbitPlayer2(targetPlayer, speed, r)

          wait(2)
        else
          if index == channel then
            chatMessage("Player not found: " .. playerName)
          end
        end

    elseif command:sub(1, 7) == "orbit3 " and table.find(bots, displayName) and cmdorbit3 then
      disablebool()
        orbitbool3 = false
        local args = command:split(" ")
        local playerName = args[2]
        local r = tonumber(args[3])
        local speed = tonumber(args[4])

        local targetPlayer = findPlayerByName(playerName)
        if targetPlayer then
          orbitbool3 = true

          if index == channel then
            chatMessage("Bots are now orbiting " .. targetPlayer.Name)
          end
          orbitPlayer3(targetPlayer, speed, r)

          wait(2)
        else
          if index == channel then
            chatMessage("Player not found: " .. playerName)
          end
        end
    elseif command:sub(1, 7) == "orbit4 " and table.find(bots, displayName) and cmdorbit4 then
      disablebool()
        orbitbool4 = false
        local args = command:split(" ")
        local playerName = args[2]
        local r = tonumber(args[3])
        local speed = tonumber(args[4])

        local targetPlayer = findPlayerByName(playerName)
        if targetPlayer then
          orbitbool4 = true

          if index == channel then
            chatMessage("Bots are now orbiting " .. targetPlayer.Name)
          end
          orbitPlayer4(targetPlayer, speed, r)

          wait(2)
        else
          if index == channel then
            chatMessage("Player not found: " .. playerName)
          end
        end

    elseif command:sub(1, 7) == "orbit6 " and table.find(bots, displayName) and cmdorbit6 then
      disablebool()
        orbitbool6 = false
        local args = command:split(" ")
        local playerName = args[2]
        local r = tonumber(args[3])
        local speed = tonumber(args[4])

        local targetPlayer = findPlayerByName(playerName)
        if targetPlayer then
          orbitbool6 = true 

          if index == channel then
            chatMessage("Bots are now orbiting " .. targetPlayer.Name)
          end
          orbitPlayer6(targetPlayer, speed, r)

          wait(2)
        else
          if index == channel then
            chatMessage("Player not found: " .. playerName)
          end
        end

    elseif command:sub(1, 7) == "orbit5 " and table.find(bots, displayName) and cmdorbit5 then
      disablebool()
        orbitbool5 = false
        local args = command:split(" ")
        local playerName = args[2]
        local r = tonumber(args[3])
        local speed = tonumber(args[4])

        local targetPlayer = findPlayerByName(playerName)
        if targetPlayer then
          orbitbool5 = true

          if index == channel then
            chatMessage("Bots are now orbiting " .. targetPlayer.Name)
          end

          orbitPlayer5(targetPlayer, speed, r)

          wait(2)
        else
          if index == channel then
            chatMessage("Player not found: " .. playerName)
          end
        end

    elseif command:sub(1, 6) == "reset" and table.find(bots, displayName) and cmdreset then
      disablebool()
        player.Character:BreakJoints()
        game.Workspace.Gravity = 196.2
        wait(2)

    elseif command:sub(1, 5) == "worm " and table.find(bots, displayName) and cmdworm then
      disablebool()
        local playerName = command:sub(6) -- Obtenir le nom du joueur à suivre
        local targetPlayer = findPlayerByName(playerName)
        wormbool = false
        worm(targetPlayer)
        wait(2)

    elseif command:sub(1, 7) == "unstalk" and table.find(bots, displayName) and cmdunstalk then
        stalkbool = false
        if index == channel then
          chatMessage("Bots stopped stalking")
        end
        wait(2)

    elseif command:sub(1, 6) == "stalk " and table.find(bots, displayName) and cmdstalk then
      disablebool()
        stalkbool = false
        local playerName = command:sub(7)
        local targetPlayer = findPlayerByName(playerName)
        stalkbool = true
        if targetPlayer then
          if index == channel then
            chatMessage("Bots are now stalking " .. targetPlayer.Name .. ".")
          end
          stalkPlayer(targetPlayer)
          wait(2)
        else
          if index == channel then
            chatMessage("Player not found: " .. playerName)
          end
        end

    elseif command:sub(1, 7) == "follow " and table.find(bots, displayName) and cmdfollow then
      disablebool()
        followbool = false
        local playerName = command:sub(8)
        local targetPlayer = findPlayerByName(playerName)
        followbool = true
        if targetPlayer then
          if index == channel then
            chatMessage("Bots are now following " .. targetPlayer.Name .. ".")
          end
          followPlayer(targetPlayer)
          wait(2)
        else
          if index == channel then
            chatMessage("Player not found: " .. playerName)
          end
        end
      end
    end
  end
 end)
end

--listen to players
player.Chatted:Connect(function(message)

end)

--listen to owner
if ownerPlayer then
  connectChatListener(ownerPlayer)
end

--listen to admins
while adminbool do
  for _, adminName in pairs(adminNotConnected) do
    local adminPlayer = game.Players:FindFirstChild(adminName)
    if adminPlayer then
      connectChatListener(adminPlayer)
      table.remove(adminNotConnected, table.find(adminNotConnected, adminName))
    end
  end
  wait(2)
end

--listen to admins
game.Players.PlayerAdded:Connect(function(player)
if table.find(Admins, player.Name) then
  connectChatListener(player)
end
end)
