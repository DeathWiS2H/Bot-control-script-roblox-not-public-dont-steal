-- BotC AI
--Configuration
getgenv().Use_Displayname = true -- if true, put accounts displayname for bots | if false use the username of accounts
getgenv().bots = {"Red", "Purple", "Blue"} --bots
getgenv().owner = "lucid_v1sion" --Owner (USER NAME, DO NOT PUT DISPLAYNAME)
getgenv().numberbot = 3 -- Number of bots you want to use
getgenv().prefix = ";" -- Prefix
getgenv().botrender = false -- when true, bots use less CPU
getgenv().CommandRegistry = CommandRegistry

--get configs | Important
local Use_Displayname = getgenv().Use_Displayname
local bots = getgenv().bots
local owner = getgenv().owner
local bot = getgenv().numberbot
local prefix = getgenv().prefix
local botrender = getgenv().botrender

-- cmd, bool and stuff
local cmdchannel = true
local cmdstatus = true
local cmdargs = true
local cmdorder = true
local cmdleft = true
local cmdright = true
local cmdup = true
local cmddown = true
local cmdend = true
local cmddance = true
local cmdundance = true
local cmdreset = true
local cmdjump = true
local cmdsay = true
local cmdreset = true
local cmdorbit = true
local cmdorbit2 = true
local cmdunorbit = true
local cmdgoto = true
local cmdadminlist = true
local cmdadmin = true
local cmdunadmin = true
local cmdcmds = true
local cmdtower = true
local cmduntower = true
local cmdfix = true
local cmdfireworks = true
local cmdfling = true
local cmdunfling = true
local cmdwalkfling = true
local cmdunwalkfling = true
local cmdexplode = true
local cmdelevator = true
local cmdunelevator = true
local cmdbridge = true
local cmdunbridge = true
local cmdnuke = true
local cmdsit = true
local cmdunsit = true
local cmdgravity = true
local cmdladder = true
local cmdunladder = true
local cmdragdoll = true
local cmdunragdoll = true
local cmdsword = true
local cmdunsword = true
local cmdshotgun = true
local cmdgun = true
local cmdsmite = true
local cmdfreeze = true
local cmdnoclip = true
local cmdclip = true
local cmdcopyanim = true
local cmdlevitate = true
local cmdfloathead = true
local cmdshuffle = true
local cmdclear = true
local cmdhaunt = true
local cmdunhaunt = true
local cmderuption = true
local cmdfakeout = true
local cmdstareat = true
local cmdunstareat = true
local cmdantichatlogs = true
local cmdunantichatlogs = true
local cmddroptools = true
local cmdgrabtools = true
local cmdungrabtools = true
local cmdusetools = true
local cmdusetool = true
local cmdperformanceboost = true
local cmdfps = true

local channel = 1
local towerbool = nil
local orbitbool = nil
local orbit2bool = nil
local ordercircle = nil
local distance = nil
local adminbool = nil
local flingbool = nil
local walkflingbool = nil
local elevatorbool = nil
local bridgebool = nil
local ladderbool = nil
local swordbool = nil
local shotgunbool = nil
local gunbool = nil
local smitebool = nil
local freezebool = nil
local noclipping = nil
local hauntbool = nil
local eruptionbool = nil
local stareatbool = nil
local Admins = {}

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TextChatService = game:GetService("TextChatService")
local VirtualUser = game:GetService("VirtualUser")

local player = game.Players.LocalPlayer
local displayName = player.DisplayName
local user = player.Name
local offset = math.random(0, 360)

local ownerPlayer = game.Players:FindFirstChild(owner)
local adminNotConnected = {}

local order

if Use_Displayname then
  for i, bot in ipairs(bots) do
    if displayName == bot then
      order = i
      break
    end
  end
else
  for i, bot in ipairs(bots) do
    if user == bot then
      order = i
      break
    end
  end
end

-- don't mess with it
if order then
  ordercircle = (360 / numberbot * order)
end

--disable/enable render (less cpu usage)
if order and botrender then
  RunService:Set3dRenderingEnabled(false)
else
  RunService:Set3dRenderingEnabled(true)
end

-- IsOrder
if not order then
  if player.Name == owner then
  else
    warn("No bot or owner corresponding with: " .. table.concat(bots, ", ") .. " or " .. owner .. " for this instance.")
    return
  end
end

-- Chat message
local function chatMessage(str)
  str = tostring(str)
  if TextChatService.ChatVersion == Enum.ChatVersion.TextChatService then
    TextChatService.TextChannels.RBXGeneral:SendAsync(str)
  else
    game.ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest:FireServer(str, "All")
  end
end

-- make life easy, with this you don't have to type someone's whole name
local function findPlayerByName(partialName)
  if partialName:lower() == "me" then
    return game.Players:FindFirstChild()
  end

  if partialName:lower() == "random" then
    local players = game.Players:GetPlayers()
    if #players > 0 then
      return players[math.random(1, #players)]
    end
  end

  local bestMatch = nil
  local bestMatchScore = 0

  for _, plr in pairs(game.Players:GetPlayers()) do
    local nameMatch = plr.Name:lower():find(partialName:lower())
    local displayNameMatch = plr.DisplayName:lower():find(partialName:lower())

    if nameMatch or displayNameMatch then
      local score = (nameMatch and #plr.Name or 0) + (displayNameMatch and #plr.DisplayName or 0)
      if score > bestMatchScore then
        bestMatchScore = score
        bestMatch = plr
      end
    end
  end

  return bestMatch
end

--no more bots flinging away with this
local function removeVelocity()
  for _, v in pairs(player.Character:GetDescendants()) do
      if v:IsA("BasePart") then
          v.Velocity = Vector3.new(0, 0, 0)
          v.RotVelocity = Vector3.new(0, 0, 0)
      elseif v:IsA("BodyVelocity") then
          v.Velocity = Vector3.new(0, 0, 0)
      elseif v:IsA("BodyAngularVelocity") then
          v.AngularVelocity = Vector3.new(0, 0, 0)
      elseif v:IsA("BodyPosition") then
          v.Position = v.Position
      elseif v:IsA("BodyGyro") then
          v.CFrame = v.CFrame
      end
  end
end

-- this function make the script a bit more smarter | Important
local function disablebool()
towerbool = false
orbitbool = false
orbit2bool = false
boolspin = false
flingbool = false
elevatorbool = false
bridgebool = false
swordbool = false
ladderbool = false
shotgunbool = false
freezebool = false
hauntbool = false
eruptionbool = false
end

-- fix
local function fix()
removeVelocity()
towerbool = false
orbitbool = false
orbit2bool = false
boolspin = false
flingbool = false
elevatorbool = false
bridgebool = false
swordbool = false
ladderbool = false
shotgunbool = false
walkflingbool = false
freezebool = false
hauntbool = false
eruptionbool = false
stareatbool = false
grabtoolsbool = false
game.Workspace.Gravity = 196.2
player.Character:BreakJoints()
end

-- left
local function left(targetPlayer, spacing)
  if not targetPlayer or not targetPlayer.Character then
      return
  end

  local targetHumanoidRootPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
  if not targetHumanoidRootPart then
      return
  end

  if player and player.Character then
      local localHumanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
      if localHumanoidRootPart then
          removeVelocity()
          local offset = targetHumanoidRootPart.CFrame.RightVector * -spacing * order
          localHumanoidRootPart.CFrame = targetHumanoidRootPart.CFrame + offset
      end
  end
end

-- right
local function right(targetPlayer, spacing)
  if not targetPlayer or not targetPlayer.Character then
      return
  end

  local targetHumanoidRootPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
  if not targetHumanoidRootPart then
      return
  end

  if player and player.Character then
      local localHumanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
      if localHumanoidRootPart then
          removeVelocity()
          local offset = targetHumanoidRootPart.CFrame.RightVector * spacing * order
          localHumanoidRootPart.CFrame = targetHumanoidRootPart.CFrame + offset
      end
  end
end

-- up
local function up(targetPlayer, spacing)
  if not targetPlayer or not targetPlayer.Character then
      return
  end

  local targetHumanoidRootPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
  if not targetHumanoidRootPart then
      return
  end

  if player and player.Character then
      local localHumanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
      if localHumanoidRootPart then
          removeVelocity()
          local offset = targetHumanoidRootPart.CFrame.LookVector * spacing * order
          localHumanoidRootPart.CFrame = targetHumanoidRootPart.CFrame + offset
      end
  end
end

-- down
local function down(targetPlayer, spacing)
  if not targetPlayer or not targetPlayer.Character then
      return
  end

  local targetHumanoidRootPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
  if not targetHumanoidRootPart then
      return
  end

  if player and player.Character then
      local localHumanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
      if localHumanoidRootPart then
          removeVelocity()
          local offset = targetHumanoidRootPart.CFrame.LookVector * -spacing * order
          localHumanoidRootPart.CFrame = targetHumanoidRootPart.CFrame + offset
      end
  end
end

-- sit
local function sit()
  local humanoid = player.Character and player.Character:FindFirstChild("Humanoid")
  if humanoid then
      humanoid.Sit = true
  end
end

-- unsit
local function unsit()
  local humanoid = player.Character and player.Character:FindFirstChild("Humanoid")
  if humanoid then
      humanoid.Sit = false
  end
end

-- goto
local function goto(targetPlayer)
  if not targetPlayer or not targetPlayer.Character then
    return
  end

  local targetHumanoidRootPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
  if not targetHumanoidRootPart then
    return
  end

  if player and player.Character then
    local localHumanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
    if localHumanoidRootPart then
      removeVelocity()
      localHumanoidRootPart.CFrame = targetHumanoidRootPart.CFrame + Vector3.new(0, 0, 0)
    end
  end
end

-- clear
local function clear()
  if game:GetService("TextChatService").ChatVersion == Enum.ChatVersion.TextChatService then game:GetService("TextChatService").TextChannels.RBXGeneral:SendAsync(".\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\.") 
  end
end

-- antilog
local function antilogs()
  if not isLegacyChat then
    if order == channel then
      chatMessage("Needs legacy chat.")
    end
    return
  end

  local speaker = game.Players.LocalPlayer
  local MessagePosted, _ = pcall(function()
      rawset(require(speaker:FindFirstChild("PlayerScripts"):FindFirstChild("ChatScript").ChatMain), "MessagePosted", {
          ["fire"] = function(msg)
              return msg
          end,
          ["wait"] = function()
              return
          end,
          ["connect"] = function()
              return
          end
      })
  end)
  
  if order == channel then
    chatMessage("Enabled.")
  end
end

-- unantilog
local function unantilogs()
  if not isLegacyChat then
    if order == channel then
      chatMessage("Needs legacy chat.")
    end
    return
  end

  local speaker = game.Players.LocalPlayer
  local MessagePosted, _ = pcall(function()
      local chatMain = require(speaker:FindFirstChild("PlayerScripts"):FindFirstChild("ChatScript").ChatMain)
      rawset(chatMain, "MessagePosted", nil)
  end)
  
  if order == channel then
    chatMessage("Disabled")
  end
end

-- ladder
local function ladder(targetPlayer)
  if ladderConnection then
      ladderConnection:Disconnect()
      ladderConnection = nil
  end

  if not targetPlayer or not targetPlayer.Character then
      return nil
  end

  local targetHumanoidRootPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
  if not targetHumanoidRootPart then
      return nil
  end

  ladderbool = true
  
  local displayName = player.DisplayName
  local botOrder = table.find(bots, displayName)

  if not botOrder then 
      return nil
  end

  local verticalSpacing = 3
  local verticalOffset = (botOrder - 1) * verticalSpacing

  local frontOffset = 1

  ladderConnection = RunService.Heartbeat:Connect(function()
      if not ladderbool or not player or not player.Character then
          if ladderConnection then
              ladderConnection:Disconnect()
              ladderConnection = nil
          end
          return
      end

      local localHumanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
      local localHumanoid = player.Character:FindFirstChild("Humanoid")

      if localHumanoidRootPart and targetHumanoidRootPart and localHumanoid then
          local targetCFrame = targetHumanoidRootPart.CFrame

          local frontPosition = targetCFrame.Position + 
                                (targetCFrame.LookVector * frontOffset) + 
                                Vector3.new(0, verticalOffset, 0)

          local rotatedCFrame = CFrame.new(frontPosition) * 
                                 targetCFrame.Rotation * 
                                 CFrame.Angles(math.rad(180), 0, 0)

          localHumanoidRootPart.CFrame = rotatedCFrame

          removeVelocity()
      else
          if ladderConnection then
              ladderConnection:Disconnect()
              ladderConnection = nil
          end
      end
  end)

  return ladderConnection
end

-- fling
local function fling(targetPlayer)
  if player and player.Character then
    local humanoid = player.Character:FindFirstChild("Humanoid")
    local humanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
    
    if humanoid and humanoidRootPart then
      humanoid:ChangeState(Enum.HumanoidStateType.Physics)
      local Spin = Instance.new("BodyAngularVelocity")
      Spin.Name = "Spinning"
      Spin.Parent = humanoidRootPart
      Spin.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
      Spin.AngularVelocity = Vector3.new(999999, 999999, 999999)
      
      local Velocity = Instance.new("BodyVelocity")
      Velocity.Name = "Upward"
      Velocity.Parent = humanoidRootPart
      Velocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
      Velocity.Velocity = Vector3.new(999999, 999999, 999999)

      flingbool = true

      if targetPlayer then
        local teleportLoop = game:GetService("RunService").Heartbeat:Connect(function()
          if not flingbool then
            teleportLoop:Disconnect()
            if Spin then
              Spin:Destroy()
            end
            if Velocity then
              Velocity:Destroy()
            end
            return
          end
          
          if targetPlayer.Character then
            local targetHumanoidRootPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
            if targetHumanoidRootPart then
              humanoidRootPart.CFrame = targetHumanoidRootPart.CFrame + targetHumanoidRootPart.CFrame.LookVector * 0
              
            end
          end
        end)
        
        task.spawn(function()
          while targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("Humanoid") and targetPlayer.Character.Humanoid.Health > 0 do
            task.wait()
          end
          teleportLoop:Disconnect()
          player.Character:BreakJoints()
          humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)

          if humanoid then
            if Spin then
              Spin:Destroy()  
            end
            if Velocity then
              Velocity:Destroy()
            end
          end
        end)
      end
    end
  end
end

-- unfling
local function unfling()
  flingbool = false
  if player and player.Character then
    local humanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
    if humanoidRootPart then
      local spin = humanoidRootPart:FindFirstChild("Spinning")
      local velocity = humanoidRootPart:FindFirstChild("Upward")
      
      if spin then
        spin:Destroy()
      end
      if velocity then
        velocity:Destroy()
      end
    end
  end
end

-- Helper function to get the character's root part
local function getRoot(char)
  return char:FindFirstChild("HumanoidRootPart") or char:FindFirstChild("Torso") or char:FindFirstChild("UpperTorso")
end

-- walkfling
local function walkfling()
  local character = player.Character
  local humanoid = character:FindFirstChildWhichIsA("Humanoid")
  local root = getRoot(character)

  if not root or not humanoid then return end

  if walkflingConnection then
      walkflingConnection:Disconnect()
      walkflingConnection = nil
  end

  walkflingbool = true

  walkflingConnection = RunService.Heartbeat:Connect(function()
      if not walkflingbool or not character or not root then
          walkflingConnection:Disconnect()
          walkflingbool = false
          return
      end

      local vel = root.Velocity

      root.Velocity = vel * 10000 + Vector3.new(0, 10000, 0)
      
      RunService.RenderStepped:Wait()
      
      if character and root then
          root.Velocity = vel
      end
      
      RunService.Stepped:Wait()
      
      if character and root then
          root.Velocity = vel + Vector3.new(0, 0.1, 0)
      end
  end)
end

-- unwalkfling
local function unwalkfling()
  walkflingbool = false
  
  if walkflingConnection then
      walkflingConnection:Disconnect()
      walkflingConnection = nil
  end
end

-- explode
local function explode(targetPlayer)
  local player = game.Players.LocalPlayer
  if not player or not player.Character then return end

  local humanoid = player.Character:FindFirstChild("Humanoid")
  local humanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")

  if not humanoid or not humanoidRootPart then return end

  humanoid:ChangeState(Enum.HumanoidStateType.Physics)

  local isExploding = true
  local startTime = tick()

  local function scatterBodyParts()
      for _, part in pairs(player.Character:GetDescendants()) do
          if part:IsA("BasePart") and part ~= humanoidRootPart then
              local randomForce = Vector3.new(
                  math.random(-20, 20),
                  math.random(30, 50),
                  math.random(-20, 20)
              )
              part.Velocity = randomForce
          end
      end
  end

  local spin1 = Instance.new("BodyAngularVelocity")
  spin1.Name = "ExplodeSpin1"
  spin1.Parent = humanoidRootPart
  spin1.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
  spin1.AngularVelocity = Vector3.new(200, 200, 200)

  local explosionConnection
  explosionConnection = game:GetService("RunService").Heartbeat:Connect(function()
      if not isExploding then
          explosionConnection:Disconnect()
          return
      end

      local elapsedTime = tick() - startTime

      if targetPlayer and targetPlayer.Character then
          local targetRootPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
          if targetRootPart then
              local offset = targetRootPart.CFrame * CFrame.new(0, 0, 0.01) * CFrame.Angles(0, math.rad(180), 0)
              humanoidRootPart.CFrame = offset
          end
      end

      if elapsedTime >= 0.1 then
          if spin1 then
              spin1:Destroy()
          end

          local spin2 = Instance.new("BodyAngularVelocity")
          spin2.Name = "ExplodeSpin2"
          spin2.Parent = humanoidRootPart
          spin2.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
          spin2.AngularVelocity = Vector3.new(50, 50, 50)

          if targetPlayer and targetPlayer.Character then
              local targetRootPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
              if targetRootPart then
                  local flingDirection = (targetRootPart.Position - humanoidRootPart.Position).unit
                  humanoidRootPart.Velocity = flingDirection * 25
              end
          else
              humanoidRootPart.Velocity = Vector3.new(
                  math.random(-30, 30),
                  math.random(40, 60),
                  math.random(-30, 30)
              )
          end
      end
  end)

  spawn(function()
      wait(0.15)

      if player.Character then
          scatterBodyParts()
          player.Character:BreakJoints()
      end

      isExploding = false

      if humanoidRootPart then
          local spin2 = humanoidRootPart:FindFirstChild("ExplodeSpin2")
          if spin2 then spin2:Destroy() end
      end

      if explosionConnection then
          explosionConnection:Disconnect()
      end
  end)
end

-- firework
local function fireworks(targetPlayer)
  if player and player.Character then
    local humanoid = player.Character:FindFirstChild("Humanoid")
    local humanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
    
    if humanoid and humanoidRootPart then
      humanoid:ChangeState(Enum.HumanoidStateType.Physics)
      
      local Velocity = Instance.new("BodyVelocity")
      Velocity.Name = "Upward"
      Velocity.Parent = humanoidRootPart
      Velocity.MaxForce = Vector3.new(0, math.huge, 0)
      
      local upwardSpeed = 45
      Velocity.Velocity = Vector3.new(
        0,
        upwardSpeed,
        0
      )
      
      local InitialSpin = Instance.new("BodyAngularVelocity")
      InitialSpin.Name = "InitialSpinning"
      InitialSpin.Parent = humanoidRootPart
      InitialSpin.MaxTorque = Vector3.new(0, math.huge, 0)
      InitialSpin.AngularVelocity = Vector3.new(0, 25, 0)
      
      local Spin = nil

      task.delay(1.9, function()
        if InitialSpin then InitialSpin:Destroy() end
        
        Spin = Instance.new("BodyAngularVelocity")
        Spin.Name = "Spinning"
        Spin.Parent = humanoidRootPart
        Spin.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
        
        local spinSpeedX = math.random(35, 60)
        local spinSpeedY = math.random(35, 60)
        local spinSpeedZ = math.random(35, 60)
        Spin.AngularVelocity = Vector3.new(spinSpeedX, spinSpeedY, spinSpeedZ)
      end)
      
      task.delay(2.0, function()
        if humanoid then
          if Spin then Spin:Destroy() end
          if Velocity then Velocity:Destroy() end
          humanoid.Health = 0
        end
      end)
      
      if targetPlayer and targetPlayer.Character then
        local targetHumanoidRootPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
        if targetHumanoidRootPart then
          local botOrder = table.find(bots, player.DisplayName) or 1
          
          local heightOffset = 0
          if botOrder == 1 then
            heightOffset = 5
          else
            heightOffset = 4 + ((botOrder - 1) * 2)
          end
          
          local targetPosition = targetHumanoidRootPart.Position + Vector3.new(0, heightOffset, 0)
          
          humanoidRootPart.CFrame = CFrame.new(targetPosition)
        end
      end
    end
  end
end

-- nuke
local function nuke(targetPlayer, height, velocity)
  if not targetPlayer or not targetPlayer.Character then
      return
  end

  local targetHumanoidRootPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
  if not targetHumanoidRootPart then
      return
  end

  local spawnPosition = targetHumanoidRootPart.Position + Vector3.new(0, height, 0)
  local player = Players.LocalPlayer
  if player and player.Character then
      local humanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
      local humanoid = player.Character and player.Character:FindFirstChild("Humanoid")
      if humanoidRootPart and humanoid then
          humanoid.Sit = true
          workspace.Gravity = 196.8

          local initialRotation = CFrame.Angles(math.pi, 0, 0)
          humanoidRootPart.CFrame = CFrame.new(spawnPosition) * initialRotation

          local nukeConnection
          local spinAngle = 0
          nukeConnection = RunService.Heartbeat:Connect(function()
              if not player or not player.Character or not targetPlayer.Character then
                  workspace.Gravity = 196.8
                  nukeConnection:Disconnect()
                  return
              end

              humanoid.Sit = true

              local targetPosition = targetHumanoidRootPart.Position
              local currentPosition = humanoidRootPart.Position

              spinAngle = spinAngle + 180

              local newCFrame = CFrame.new(
                  targetPosition.X, 
                  currentPosition.Y - 1,
                  targetPosition.Z
              ) * CFrame.Angles(math.pi, spinAngle, 0)

              humanoidRootPart.CFrame = newCFrame

              local raycastParams = RaycastParams.new()
              raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
              raycastParams.FilterDescendantsInstances = {player.Character}

              local raycastResult = workspace:Raycast(
                  humanoidRootPart.Position, 
                  Vector3.new(0, -10, 0), 
                  raycastParams
              )

              if raycastResult and raycastResult.Distance <= 2.5 then
                  local teleportConnection
                  teleportConnection = RunService.Heartbeat:Connect(function()
                      if not player or not player.Character or not targetPlayer.Character then
                          workspace.Gravity = 196.8
                          teleportConnection:Disconnect()
                          return
                      end

                      humanoid.Sit = true

                      local teleportCFrame = targetHumanoidRootPart.CFrame * CFrame.new(0, 0, 0) * CFrame.Angles(math.pi, 0, 0)
                      humanoidRootPart.CFrame = teleportCFrame

                      local spinVelocity = Instance.new("BodyAngularVelocity")
                      spinVelocity.AngularVelocity = Vector3.new(velocity, velocity, velocity)
                      spinVelocity.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
                      spinVelocity.Parent = humanoidRootPart

                      local bodyVelocity = Instance.new("BodyVelocity")
                      bodyVelocity.Velocity = Vector3.new(0, 0, 0)
                      bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                      bodyVelocity.Parent = humanoidRootPart

                      local distanceToTarget = (humanoidRootPart.Position - targetHumanoidRootPart.Position).Magnitude
                      if distanceToTarget <= 1 then
                          wait(0.25)
                          player.Character:BreakJoints()

                          workspace.Gravity = 196.8
                          nukeConnection:Disconnect()
                          teleportConnection:Disconnect()
                      end
                  end)

                  nukeConnection:Disconnect()
              end
          end)
      end
  end
end

-- ragdoll
local function ragdoll()
  local humanoid = player.Character and player.Character:FindFirstChild("Humanoid")
  if humanoid then
      humanoid:ChangeState(Enum.HumanoidStateType.Physics)
  end
end

-- unragdoll
local function unragdoll()
  local humanoid = player.Character and player.Character:FindFirstChild("Humanoid")
  if humanoid then
      humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
  end
end

-- gravity
local function setGravity(gravityValue)
  gravityValue = tonumber(gravityValue) or 196.2
  game.Workspace.Gravity = gravityValue
end

-- undance
local function undance()
  local character = player.Character
  if character then
      local humanoid = character:FindFirstChildOfClass("Humanoid")
      if humanoid then
          for _, track in pairs(humanoid:GetPlayingAnimationTracks()) do
              track:Stop()
          end
      end
  end
end

-- levitate
local function levitate()
  local character = player.Character
  if character then
      local humanoid = character:FindFirstChildOfClass("Humanoid")
      if humanoid then
          local animation = Instance.new("Animation")
          animation.AnimationId = "rbxassetid://313762630"
          local animationTrack = humanoid:LoadAnimation(animation)
          animationTrack:Play()
      end
  end
end

-- floathead
local function floathead()
  local character = player.Character
  if character then
      local humanoid = character:FindFirstChildOfClass("Humanoid")
      if humanoid then
          local animation = Instance.new("Animation")
          animation.AnimationId = "rbxassetid://121572214"
          local animationTrack = humanoid:LoadAnimation(animation)
          animationTrack:Play()
      end
  end
end

-- shuffle
local function shuffle()
  local character = player.Character
  if character then
      local humanoid = character:FindFirstChildOfClass("Humanoid")
      if humanoid then
          local animation = Instance.new("Animation")
          animation.AnimationId = "rbxassetid://429703734"
          local animationTrack = humanoid:LoadAnimation(animation)
          animationTrack:Play()
      end
  end
end

-- copyanim
local function copyanim(targetPlayer, speed)
  if not targetPlayer or not targetPlayer.Character then
      return
  end

  local targetHumanoid = targetPlayer.Character:FindFirstChildOfClass('Humanoid')
  local speakerHumanoid = player.Character:FindFirstChildOfClass('Humanoid')

  if not targetHumanoid or not speakerHumanoid then
      return
  end

  -- Stop current animations
  for _, animTrack in pairs(speakerHumanoid:GetPlayingAnimationTracks()) do
      animTrack:Stop()
  end
  
  -- Copy target animations
  for _, targetAnimTrack in pairs(targetHumanoid:GetPlayingAnimationTracks()) do
      if not string.find(targetAnimTrack.Animation.AnimationId, "507768375") then
          local copiedAnim = speakerHumanoid:LoadAnimation(targetAnimTrack.Animation)

          local animSpeed = speed or 1
          copiedAnim:Play(0.1, 1, targetAnimTrack.Speed * animSpeed)
          
          copiedAnim.TimePosition = targetAnimTrack.TimePosition
          
          task.spawn(function()
              targetAnimTrack.Stopped:Wait()

              copiedAnim:Stop()
              copiedAnim:Destroy()
          end)
      end
  end
end

-- fakeout
local function fakeout()
  local OrgDestroyHeight = workspace.FallenPartsDestroyHeight
  
  if player and player.Character then
      local root = getRoot(player.Character)
      
      if root then
          local oldpos = root.CFrame

          workspace.FallenPartsDestroyHeight = 0/1/0

          root.CFrame = CFrame.new(Vector3.new(0, OrgDestroyHeight - 25, 0))

          wait(1)
          
          root.CFrame = oldpos

          workspace.FallenPartsDestroyHeight = OrgDestroyHeight
      end
  end
end

-- stareat
local function stareat(targetPlayer)
  if not targetPlayer or not targetPlayer.Character then
      return
  end

  local targetHumanoidRootPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
  if not targetHumanoidRootPart then
      return
  end

  stareatbool = true

  stareatConnection = RunService.Heartbeat:Connect(function()
      if not stareatbool or not player or not player.Character then
          if stareatConnection then
              stareatConnection:Disconnect()
              stareatConnection = nil
          end
          return
      end

      local localHumanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
      if localHumanoidRootPart then
          local currentPosition = localHumanoidRootPart.Position

          local targetPosition = Vector3.new(targetHumanoidRootPart.Position.X, currentPosition.Y, targetHumanoidRootPart.Position.Z)

          localHumanoidRootPart.CFrame = CFrame.lookAt(currentPosition, targetPosition)
      end
  end)
end

-- elevator
local function elevator(targetPlayer, initialDistance)
  if elevatorConnection then
      elevatorConnection:Disconnect()
      elevatorConnection = nil
  end

  if not targetPlayer or not targetPlayer.Character then
      return nil
  end

  local targetHumanoidRootPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
  if not targetHumanoidRootPart then
      return nil
  end

  elevatorbool = true
  
  local displayName = player.DisplayName
  local botOrder = table.find(bots, displayName)

  if not botOrder then 
      return nil
  end

  local horizontalSpacing = 1.5
  local verticalOffset = -3.2

  local horizontalOffset
  if botOrder == 1 then
      horizontalOffset = 0
  else
      horizontalOffset = (botOrder % 2 == 0) and 
                         (math.ceil(botOrder/2) * horizontalSpacing) or 
                         (-math.floor(botOrder/2) * horizontalSpacing)
  end

  elevatorConnection = RunService.Heartbeat:Connect(function()
      if not elevatorbool or not player or not player.Character then
          if elevatorConnection then
              elevatorConnection:Disconnect()
              elevatorConnection = nil
          end
          return
      end

      local localHumanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
      local localHumanoid = player.Character:FindFirstChild("Humanoid")

      if localHumanoidRootPart and targetHumanoidRootPart and localHumanoid then
          local targetCFrame = targetHumanoidRootPart.CFrame

          local desiredPosition = targetCFrame.Position + 
                                  targetCFrame.RightVector * horizontalOffset + 
                                  Vector3.new(0, verticalOffset, 0)

          local rotatedCFrame = CFrame.new(desiredPosition) * 
                                (targetCFrame - targetCFrame.Position) * 
                                CFrame.Angles(math.rad(90), 0, 0)

          localHumanoidRootPart.CFrame = rotatedCFrame
      else
          if elevatorConnection then
              elevatorConnection:Disconnect()
              elevatorConnection = nil
          end
      end
  end)

  return elevatorConnection
end

-- noclip
local function noclip()
  Clip = false
  wait(0.1)

  local function NoclipLoop()
      if not Clip and player.Character ~= nil then
          for _, child in pairs(player.Character:GetDescendants()) do
              if child:IsA("BasePart") and child.CanCollide == true then
                  child.CanCollide = false
              end
          end
      end
  end

  Noclipping = RunService.Stepped:Connect(NoclipLoop)
end

-- clip
local function clip()
  if Noclipping then
      Noclipping:Disconnect()
  end

  Clip = true

  if player.Character then
      for _, child in pairs(player.Character:GetDescendants()) do
          if child:IsA("BasePart") then
              child.CanCollide = true
          end
      end
  end
end

-- droptools
function dropTools()
  for i, v in pairs(Players.LocalPlayer.Backpack:GetChildren()) do
      if v:IsA("Tool") then
          v.Parent = Players.LocalPlayer.Character
      end
  end
  for i, v in pairs(Players.LocalPlayer.Character:GetChildren()) do
      if v:IsA("Tool") then
          v.Parent = workspace
      end
  end
end

-- grabtools
local function grabtools()
  if grabtoolsbool then return end
  
  grabtoolsbool = true
  local humanoid = Players.LocalPlayer.Character:FindFirstChildWhichIsA("Humanoid")

  for _, child in ipairs(workspace:GetChildren()) do
      if child:IsA("Tool") and child:FindFirstChild("Handle") then
          humanoid:EquipTool(child)
      end
  end

  if grabToolsConnection then 
      grabToolsConnection:Disconnect() 
  end

  grabToolsConnection = workspace.ChildAdded:Connect(function(child)
      if not grabtoolsbool then return end
      
      if child:IsA("Tool") and child:FindFirstChild("Handle") then
          humanoid:EquipTool(child)
      end
  end)
end

-- ungrabtools
local function ungrabtools()
  if not grabtoolsbool then return end
  
  grabtoolsbool = false
  
  if grabToolsConnection then 
      grabToolsConnection:Disconnect() 
      grabToolsConnection = nil
  end
end

-- usetools
local function usetools(amount, delay)
  local Backpack = Players.LocalPlayer:FindFirstChildOfClass("Backpack")

  for _, v in ipairs(Backpack:GetChildren()) do
      v.Parent = Players.LocalPlayer.Character
      task.spawn(function()
          for _ = 1, amount do
              v:Activate()
              if delay then
                wait(delay)
              end
          end
          v.Parent = Backpack
      end)
  end
end

-- usetool
local function usetool(slotNumber)
  local Backpack = Players.LocalPlayer:FindFirstChildOfClass("Backpack")

  local tools = {}
  for _, tool in ipairs(Backpack:GetChildren()) do
      if tool:IsA("Tool") then
          table.insert(tools, tool)
      end
  end

  if slotNumber < 1 then
    slotNumber = 1
  end
  
  if slotNumber > #tools then
      slotNumber = #tools
  end

  local selectedTool = tools[slotNumber]
  
  if selectedTool then
      selectedTool.Parent = Players.LocalPlayer.Character
      task.spawn(function()
          selectedTool:Activate()
          task.wait(0.1)
          selectedTool.Parent = Backpack
      end)
  end
end

-- sword
local function sword(targetPlayer, initialDistance, subsequentSpacing, velocityMagnitude)
  if swordConnection then
      swordConnection:Disconnect()
      swordConnection = nil
  end

  if not targetPlayer or not targetPlayer.Character then
      return nil
  end

  local targetHumanoidRootPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
  if not targetHumanoidRootPart then
      return nil
  end

  swordbool = true

  local displayName = player.DisplayName
  local botOrder = table.find(bots, displayName)

  if not botOrder then 
      return nil
  end

  if velocityMagnitude > 0 then
      velocityMagnitude = -velocityMagnitude
  end

  local forwardDistance
  if botOrder == 1 then
      forwardDistance = initialDistance
  else
      forwardDistance = initialDistance + ((botOrder - 1) * subsequentSpacing)
  end

  swordConnection = RunService.Heartbeat:Connect(function()
      if not swordbool or not player or not player.Character then
          if swordConnection then
              swordConnection:Disconnect()
              swordConnection = nil
          end
          return
      end

      local localHumanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
      local localHumanoid = player.Character:FindFirstChild("Humanoid")

      if localHumanoidRootPart and targetHumanoidRootPart and localHumanoid then
          local targetCFrame = targetHumanoidRootPart.CFrame

          local forwardVector = targetCFrame.LookVector * forwardDistance
          local desiredPosition = targetCFrame.Position + forwardVector

          local rotatedCFrame = CFrame.lookAt(desiredPosition, targetCFrame.Position) * CFrame.Angles(math.rad(90), 0, 0)

          localHumanoidRootPart.CFrame = rotatedCFrame

          local velocityDirection = (targetHumanoidRootPart.Position - localHumanoidRootPart.Position).Unit
          
          localHumanoidRootPart.Velocity = velocityDirection * velocityMagnitude
      else
          if swordConnection then
              swordConnection:Disconnect()
              swordConnection = nil
          end
      end
  end)

  return swordConnection
end

-- freeze
local function freeze()
  local humanoid = player.Character and player.Character:FindFirstChild("Humanoid")
  local humanoidRootPart = player.Character and player.Character:FindFirstChild("HumanoidRootPart")

  freezebool = true

  if humanoid and humanoidRootPart then
      humanoid:ChangeState(Enum.HumanoidStateType.Physics)

      humanoidRootPart.Velocity = Vector3.new(0, 0, 0)
      humanoidRootPart.RotVelocity = Vector3.new(0, 0, 0)

      local bodyPosition = Instance.new("BodyPosition")
      bodyPosition.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
      bodyPosition.Position = humanoidRootPart.Position
      bodyPosition.Parent = humanoidRootPart

      local bodyGyro = Instance.new("BodyGyro")
      bodyGyro.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
      bodyGyro.CFrame = humanoidRootPart.CFrame
      bodyGyro.Parent = humanoidRootPart
  end
end

-- unfreeze
local function unfreeze()
  local humanoidRootPart = player.Character and player.Character:FindFirstChild("HumanoidRootPart")

  freezebool = false

  if humanoidRootPart then
      local bodyPosition = humanoidRootPart:FindFirstChild("BodyPosition")
      if bodyPosition then
          bodyPosition:Destroy()
      end

      local bodyGyro = humanoidRootPart:FindFirstChild("BodyGyro")
      if bodyGyro then
          bodyGyro:Destroy()
      end

      local humanoid = player.Character and player.Character:FindFirstChild("Humanoid")
      if humanoid then
          humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
      end
  end
end

-- eruption
local function eruption(targetPlayer, velocity)
  if eruptionConnection then
      eruptionConnection:Disconnect()
      eruptionConnection = nil
  end

  if not targetPlayer or not targetPlayer.Character then
      return nil
  end

  local targetHumanoidRootPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
  if not targetHumanoidRootPart then
      return nil
  end

  eruptionbool = true

  local displayName = player.DisplayName
  local botIndex = table.find(bots, displayName)

  if not botIndex then 
      return nil
  end

  local verticalOffset = -6

  eruptionConnection = RunService.Heartbeat:Connect(function()
      if not eruptionbool or not player or not player.Character then
          if eruptionConnection then
              eruptionConnection:Disconnect()
              eruptionConnection = nil
          end
          return
      end

      local localHumanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
      local localHumanoid = player.Character:FindFirstChild("Humanoid")

      if localHumanoidRootPart and targetHumanoidRootPart and localHumanoid then
          local targetCFrame = targetHumanoidRootPart.CFrame

          local desiredPosition = targetCFrame.Position + 
                                  Vector3.new(0, verticalOffset, 0)

          local finalCFrame = CFrame.new(desiredPosition)

          localHumanoidRootPart.CFrame = finalCFrame

          local randomVelocity = Vector3.new(0, velocity, 0)
          localHumanoidRootPart.Velocity = randomVelocity

          task.wait(0.01)
          if localHumanoidRootPart then
              localHumanoidRootPart.AssemblyAngularVelocity = Vector3.new(math.random(-35, 35), math.random(-35, 35), math.random(-35, 35))
          end

          local newCFrame = CFrame.new(targetCFrame.Position + Vector3.new(0, verticalOffset, 0))
          localHumanoidRootPart.CFrame = newCFrame

          local humanoid = player.Character and player.Character:FindFirstChild("Humanoid")
          if humanoid then
              humanoid:ChangeState(Enum.HumanoidStateType.Physics)
          end

          task.delay(0.5, function()
              if targetPlayer and targetPlayer.Character and localHumanoid then
                  localHumanoid.Health = 0
                  if eruptionConnection then
                      eruptionConnection:Disconnect()
                      eruptionConnection = nil
                  end
              end
          end)

      else
          if eruptionConnection then
              eruptionConnection:Disconnect()
              eruptionConnection = nil
          end
      end
  end)

  return eruptionConnection
end

-- smite
local function smite(targetPlayer, height, velocity)
  if smiteConnection then
      smiteConnection:Disconnect()
      smiteConnection = nil
  end

  if not targetPlayer or not targetPlayer.Character then
      return
  end

  local targetRoot = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
  local targetHumanoid = targetPlayer.Character:FindFirstChild("Humanoid")

  if not targetRoot or not targetHumanoid then
      return
  end

  local playerRoot = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
  local humanoid = player.Character and player.Character:FindFirstChild("Humanoid")

  if not playerRoot or not humanoid then
      return
  end

  smitebool = true

  if not table.find(bots, player.DisplayName) then
      return
  end

  humanoid:ChangeState(Enum.HumanoidStateType.Physics)
  local verticalOffset = height
  local appliedVelocity = velocity

  smiteConnection = RunService.Heartbeat:Connect(function()
      if not smitebool or not player.Character then
          smiteConnection:Disconnect()
          smiteConnection = nil
          return
      end

      local targetPosition = targetRoot.Position
      local desiredPosition = targetPosition + Vector3.new(0, verticalOffset, 0)
      playerRoot.CFrame = CFrame.lookAt(desiredPosition, targetPosition) * CFrame.Angles(math.rad(90), 0, 0)
      playerRoot.Velocity = (targetPosition - playerRoot.Position).Unit * appliedVelocity
  end)

  task.delay(0.25, function()
      if targetPlayer and targetPlayer.Character and targetHumanoid then
          player.Character:BreakJoints()
      end
  end)
end

-- shotgun
local function shotgun(targetPlayer, initialDistance)
  if shotgunConnection then
      shotgunConnection:Disconnect()
      shotgunConnection = nil
  end

  if not targetPlayer or not targetPlayer.Character then
      return nil
  end

  local targetHumanoidRootPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
  if not targetHumanoidRootPart then
      return nil
  end

  shotgunbool = true
  
  local displayName = player.DisplayName
  local botOrder = table.find(bots, displayName)

  if not botOrder then 
      return nil
  end

  local subsequentSpacing = 2.5

  local forwardDistance
  if botOrder == 1 then
      forwardDistance = initialDistance
  else
      forwardDistance = initialDistance + ((botOrder - 1) * subsequentSpacing)
  end

  local initialVelocity = Vector3.new(0, 0, 0)
  local velocityTimer = nil
  local stateChangeTimer = nil
  local sitTimer = nil
  local unsitTimer = nil
  local velocityEnabled = false

  shotgunConnection = RunService.Heartbeat:Connect(function()
      if not shotgunbool or not player or not player.Character then
          if shotgunConnection then
              shotgunConnection:Disconnect()
              shotgunConnection = nil
          end
          return
      end

      local localHumanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
      local localHumanoid = player.Character:FindFirstChild("Humanoid")

      if localHumanoidRootPart and targetHumanoidRootPart and localHumanoid then
          local targetCFrame = targetHumanoidRootPart.CFrame

          local forwardVector = targetCFrame.LookVector * forwardDistance

          local desiredPosition = targetCFrame.Position + forwardVector

          local rotatedCFrame = CFrame.lookAt(desiredPosition, targetCFrame.Position) * CFrame.Angles(math.rad(90), 0, 0)

          localHumanoidRootPart.CFrame = rotatedCFrame

          local velocityDirection = (targetHumanoidRootPart.Position - localHumanoidRootPart.Position).Unit
          local velocityMagnitude = -500
          
          if velocityEnabled then
              local currentVelocity = velocityDirection * velocityMagnitude
              localHumanoidRootPart.Velocity = currentVelocity
              
              if initialVelocity.Magnitude == 0 then
                  initialVelocity = currentVelocity
              end
          else
              localHumanoidRootPart.Velocity = Vector3.new(0, 0, 0)
          end

          if not velocityTimer then
              velocityTimer = task.delay(3, function()
                  player.Character:BreakJoints()
                  
                  shotgunbool = false
                  if shotgunConnection then
                      shotgunConnection:Disconnect()
                      shotgunConnection = nil
                  end
              end)
          end

          if not sitTimer then
              sitTimer = task.delay(2, function()
                  sit()
              end)
          end

          if not stateChangeTimer then
              stateChangeTimer = task.delay(2, function()
                  if localHumanoid then
                      localHumanoid:ChangeState(Enum.HumanoidStateType.Seated)
                  end
              end)
          end

          if not unsitTimer then
              unsitTimer = task.delay(2.5, function()
                  if localHumanoid then
                      localHumanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
                      velocityEnabled = true
                  end
              end)
          end
      else
          if shotgunConnection then
              shotgunConnection:Disconnect()
              shotgunConnection = nil
          end
      end
  end)

  return shotgunConnection
end

-- haunt
local function haunt(targetPlayer)
  if not targetPlayer then return nil end
  
  if hauntConnection then
      hauntConnection:Disconnect()
      hauntConnection = nil
  end

  hauntbool = true
  
  local character = player.Character or player.CharacterAdded:Wait()
  local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
  local humanoid = character:WaitForChild("Humanoid")
  local head = character:WaitForChild("Head")
  
  if humanoid then
      humanoid:ChangeState(Enum.HumanoidStateType.Physics)
  end
  
  local followDistance = -0.1
  local teleportDistance = -0.1
  
  local repulsionRadius = 5
  local repulsionForce = 8
  
  local leaderRootPart = nil
  
  local positionVelocity = Vector3.new(0, 0, 0)
  local springVelocityY = 0
  local stiffnessX = 2
  local dampingX = 0.5
  local stiffnessY = 2
  local dampingY = 0.5
  local jumpBoost = 2.5
  local bounceFactor = 0.5
  local raycastLength = 3
  
  local originalGravity = game.Workspace.Gravity
  game.Workspace.Gravity = 0
  
  local function findRoot()
      if targetPlayer and targetPlayer.Character then
          leaderRootPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
          return leaderRootPart ~= nil
      end
      return false
  end
  
  if not findRoot() then 
      hauntbool = false
      return nil
  end
  
  local leaderCFrame = leaderRootPart.CFrame
  local teleportPosition = leaderCFrame.Position - (leaderCFrame.LookVector * teleportDistance)
  humanoidRootPart.CFrame = CFrame.new(teleportPosition, leaderRootPart.Position)
  
  local lastLeaderY = leaderRootPart.Position.Y
  
  local function isTouchingGround()
      local origin = humanoidRootPart.Position
      local direction = Vector3.new(0, -raycastLength, 0)
      local params = RaycastParams.new()
      params.FilterDescendantsInstances = {character}
      params.FilterType = Enum.RaycastFilterType.Blacklist
      
      local result = game.Workspace:Raycast(origin, direction, params)
      return result ~= nil
  end
  
  local function checkBotRepulsion()
      local nearbyParts = game.Workspace:GetPartBoundsInRadius(humanoidRootPart.Position, repulsionRadius)
      local repulsionVector = Vector3.new(0, 0, 0)
      
      for _, part in ipairs(nearbyParts) do
          local nearbyCharacter = part:FindFirstAncestorOfClass("Model")
          if nearbyCharacter and nearbyCharacter ~= character then
              local nearbyRootPart = nearbyCharacter:FindFirstChild("HumanoidRootPart")
              if nearbyRootPart then
                  local repulsionDirection = (humanoidRootPart.Position - nearbyRootPart.Position).Unit
                  local distance = (humanoidRootPart.Position - nearbyRootPart.Position).Magnitude
                  
                  local inverseFalloff = math.max(0, 1 - (distance / repulsionRadius))
                  repulsionVector = repulsionVector + (repulsionDirection * repulsionForce * inverseFalloff)
              end
          end
      end
      
      return repulsionVector
  end
  
  hauntConnection = game:GetService("RunService").Heartbeat:Connect(function(dt)
      if not hauntbool or not player or not player.Character then
          if hauntConnection then
              hauntConnection:Disconnect()
              hauntConnection = nil
          end
          game.Workspace.Gravity = originalGravity
          if humanoid then 
              humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
          end
          return
      end
      
      if not findRoot() then
          hauntbool = false
          if hauntConnection then
              hauntConnection:Disconnect()
              hauntConnection = nil
          end
          game.Workspace.Gravity = originalGravity
          humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
          return
      end
      
      local leaderCFrame = leaderRootPart.CFrame
      local targetPosition = leaderCFrame.Position - (leaderCFrame.LookVector * followDistance)
      
      local displacement = targetPosition - humanoidRootPart.Position
      
      local yDisplacement = leaderRootPart.Position.Y - humanoidRootPart.Position.Y
      local yAcceleration = (yDisplacement * stiffnessY) - (springVelocityY * dampingY)
      
      if leaderRootPart.Position.Y > lastLeaderY + 1 then
          springVelocityY = springVelocityY + jumpBoost
      end
      lastLeaderY = leaderRootPart.Position.Y
      
      springVelocityY = springVelocityY + yAcceleration * dt
      
      if isTouchingGround() and springVelocityY < 0 then
          springVelocityY = -springVelocityY * bounceFactor
      end
      
      local newY = humanoidRootPart.Position.Y + springVelocityY * dt
      
      local repulsionVector = checkBotRepulsion()
      
      local acceleration = displacement * stiffnessX - positionVelocity * dampingX
      positionVelocity = positionVelocity + acceleration * dt + repulsionVector * dt
      
      local newPosition = Vector3.new(
          humanoidRootPart.Position.X + positionVelocity.X * dt, 
          newY, 
          humanoidRootPart.Position.Z + positionVelocity.Z * dt
      )
      
      humanoidRootPart.CFrame = CFrame.new(newPosition, leaderRootPart.Position)
      head.CFrame = CFrame.Lerp(head.CFrame, leaderRootPart.CFrame, 0.1)
  end)
  return hauntConnection
end

-- elevator
local function elevator(targetPlayer)
  if elevatorConnection then
      elevatorConnection:Disconnect()
      elevatorConnection = nil
  end

  if not targetPlayer or not targetPlayer.Character then
      return nil
  end

  local targetHumanoidRootPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
  if not targetHumanoidRootPart then
      return nil
  end

  elevatorbool = true
  
  local displayName = player.DisplayName
  local botOrder = table.find(bots, displayName)

  if not botOrder then 
      return nil
  end

  local horizontalSpacing = 0
  local verticalOffset = -2.5

  local horizontalOffset
  if botOrder == 1 then
      horizontalOffset = 0
  else
      horizontalOffset = (botOrder % 2 == 0) and 
                         (math.ceil(botOrder/2) * horizontalSpacing) or 
                         (-math.floor(botOrder/2) * horizontalSpacing)
  end

  elevatorConnection = RunService.Heartbeat:Connect(function()
      if not elevatorbool or not player or not player.Character then
          if elevatorConnection then
              elevatorConnection:Disconnect()
              elevatorConnection = nil
          end
          return
      end

      local localHumanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
      local localHumanoid = player.Character:FindFirstChild("Humanoid")

      if localHumanoidRootPart and targetHumanoidRootPart and localHumanoid then
          local targetCFrame = targetHumanoidRootPart.CFrame

          local desiredPosition = targetCFrame.Position + 
                                  targetCFrame.RightVector * horizontalOffset + 
                                  Vector3.new(0, verticalOffset, 0)

          local rotatedCFrame = CFrame.new(desiredPosition) * 
                                (targetCFrame - targetCFrame.Position) * 
                                CFrame.Angles(math.rad(90), 0, 0)

          localHumanoidRootPart.CFrame = rotatedCFrame

          removeVelocity()
      else
          if elevatorConnection then
              elevatorConnection:Disconnect()
              elevatorConnection = nil
          end
      end
  end)

  return elevatorConnection
end

-- bridge
local function bridge(targetPlayer, initialDistance, spacing)
  if bridgeConnection then
      bridgeConnection:Disconnect()
      bridgeConnection = nil
  end

  if not targetPlayer or not targetPlayer.Character then
      return nil
  end

  local targetHumanoidRootPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
  if not targetHumanoidRootPart then
      return nil
  end

  bridgebool = true

  local displayName = player.DisplayName
  local botOrder = table.find(bots, displayName)

  if not botOrder then 
      return nil
  end

  -- Use provided initial distance or default to 2.5
  local baseForwardDistance = initialDistance
  
  -- Use provided spacing or calculate based on bot order
  local forwardDistance = baseForwardDistance * (botOrder * (spacing))

  bridgeConnection = RunService.Heartbeat:Connect(function()
      if not bridgebool or not player or not player.Character then
          if bridgeConnection then
              bridgeConnection:Disconnect()
              bridgeConnection = nil
          end
          return
      end

      local localHumanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
      local localHumanoid = player.Character:FindFirstChild("Humanoid")

      if localHumanoidRootPart and targetHumanoidRootPart and localHumanoid then
          local targetCFrame = targetHumanoidRootPart.CFrame

          local forwardVector = targetCFrame.LookVector * forwardDistance

          local desiredPosition = targetCFrame.Position + forwardVector

          local rotatedCFrame = CFrame.lookAt(desiredPosition, targetCFrame.Position) * CFrame.Angles(math.rad(90), 0, 0)

          localHumanoidRootPart.CFrame = rotatedCFrame

          removeVelocity()
      else
          if bridgeConnection then
              bridgeConnection:Disconnect()
              bridgeConnection = nil
          end
      end
  end)

  return bridgeConnection
end

-- tower
local function tower(targetPlayer)
  if not targetPlayer or not targetPlayer.Character then
      return
  end

  local targetHumanoidRootPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
  if not targetHumanoidRootPart then
    return
  end

  towerbool = true

  local heartbeatConnection
  heartbeatConnection = RunService.Heartbeat:Connect(function()
      if not towerbool or not targetHumanoidRootPart or not targetPlayer.Character then
          heartbeatConnection:Disconnect()
          return
      end

      if player and player.Character then
          local localHumanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
          if localHumanoidRootPart then
              local offset = targetHumanoidRootPart.CFrame.UpVector * 5 * order
              localHumanoidRootPart.CFrame = targetHumanoidRootPart.CFrame + offset

              removeVelocity()
          end
      end
  end)
end

-- spin from IY
local function spin(spinSpeed)
  local character = player.Character or player.CharacterAdded:Wait()

  local root = character:FindFirstChild("HumanoidRootPart")

  if root then
    local existingSpin = root:FindFirstChild("Spinning")
    if existingSpin then
      existingSpin:Destroy()
    end

    local Spin = Instance.new("BodyAngularVelocity")
    Spin.Name = "Spinning"
    Spin.Parent = root
    Spin.MaxTorque = Vector3.new(0, math.huge, 0)
    Spin.AngularVelocity = Vector3.new(0, spinSpeed, 0)

    while boolspin do
      wait(0.1)
    end

    Spin:Destroy()
  end
end

-- orbit
local function orbit(targetPlayer, speed, radius)
  if currentOrbitConnection then
    currentOrbitConnection:Disconnect()
    currentOrbitConnection = nil
  end

  if not targetPlayer or not targetPlayer.Character then
      return
  end

  local targetHumanoidRootPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
  if not targetHumanoidRootPart then
      return
  end

  orbitbool = true
  
  if radius == 0 then
    radius = 0.0001
  end

  local botOrder = order or 1

  local initialAngle = (360 / numberbot) * (botOrder - 1)
  
  currentOrbitConnection = RunService.Heartbeat:Connect(function()
      if not orbitbool or not player or not player.Character then
          if currentOrbitConnection then
              currentOrbitConnection:Disconnect()
              currentOrbitConnection = nil
          end
          game.Workspace.Gravity = 196.2
          return
      end

      local localHumanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
      
      if localHumanoidRootPart and targetHumanoidRootPart then
          initialAngle = initialAngle + speed
          
          local x = radius * math.cos(math.rad(initialAngle))
          local z = radius * math.sin(math.rad(initialAngle))

          local orbitPosition = targetHumanoidRootPart.Position + Vector3.new(x, 0, z)

          localHumanoidRootPart.CFrame = CFrame.new(orbitPosition, targetHumanoidRootPart.Position)

          game.Workspace.Gravity = 0
          
          removeVelocity()
      else
          if currentOrbitConnection then
              currentOrbitConnection:Disconnect()
              currentOrbitConnection = nil
          end
          game.Workspace.Gravity = 196.2
      end
  end)
end

-- performanceboost
local function performanceboost()
  local Terrain = workspace:FindFirstChildOfClass('Terrain')

  if Terrain then
      Terrain.WaterWaveSize = 0
      Terrain.WaterWaveSpeed = 0
      Terrain.WaterReflectance = 0
      Terrain.WaterTransparency = 0
  end

  local Lighting = game:GetService("Lighting")
  Lighting.GlobalShadows = false
  Lighting.FogEnd = 9e9

  settings().Rendering.QualityLevel = 1

  for _, v in pairs(game:GetDescendants()) do
      if v:IsA("Part") or v:IsA("UnionOperation") or v:IsA("MeshPart") or v:IsA("CornerWedgePart") or v:IsA("TrussPart") then
          v.Material = Enum.Material.Plastic
          v.Reflectance = 0
      elseif v:IsA("Decal") then
          v.Transparency = 1
      elseif v:IsA("ParticleEmitter") or v:IsA("Trail") then
          v.Lifetime = NumberRange.new(0)
      elseif v:IsA("Explosion") then
          v.BlastPressure = 1
          v.BlastRadius = 1
      end
  end

  for _, v in pairs(Lighting:GetDescendants()) do
      if v:IsA("BlurEffect") or v:IsA("SunRaysEffect") or v:IsA("ColorCorrectionEffect") or v:IsA("BloomEffect") or v:IsA("DepthOfFieldEffect") then
          v.Enabled = false
      end
  end

  workspace.DescendantAdded:Connect(function(child)
      task.spawn(function()
          if child:IsA('ForceField') or child:IsA('Sparkles') or child:IsA('Smoke') or child:IsA('Fire') then
              RunService.Heartbeat:Wait()
              child:Destroy()
          end
      end)
  end)
end

-- fps
local function fps(number)
  if fpscaploop then
      task.cancel(fpscaploop)
      fpscaploop = nil
  end

  local fpsCap = 60
  local num = tonumber(number) or 1e6

  if number == "none" then
      return
  elseif num > 0 then
      fpsCap = num
  else
      return
  end

  if setfpscap and type(setfpscap) == "function" then
      setfpscap(fpsCap)
  else
      fpscaploop = task.spawn(function()
          local timer = os.clock()
          while true do
              if os.clock() >= timer + 1 / fpsCap then
                  timer = os.clock()
                  task.wait()
              end
              task.wait()
          end
      end)
  end
end

-- Command Registry
local CommandRegistry = {
    commands = {},
    aliases = {}
}

function CommandRegistry:addCommand(name, func, options)
    options = options or {}
    
    -- Validate input
    if type(name) ~= "string" or type(func) ~= "function" then
        warn("Invalid command registration: name must be a string, func must be a function")
        return false
    end

    -- Store the command
    self.commands[name:lower()] = {
        func = func,
        description = options.description or "No description provided",
        usage = options.usage or "No usage information",
        aliases = options.aliases or {}
    }

    -- Register aliases
    if options.aliases then
        for _, alias in ipairs(options.aliases) do
            self.aliases[alias:lower()] = name:lower()
        end
    end

    return true
end

function CommandRegistry:removeCommand(name)
    name = name:lower()
    
    if self.commands[name] then
        -- Remove aliases
        for _, alias in ipairs(self.commands[name].aliases) do
            self.aliases[alias:lower()] = nil
        end
        
        -- Remove the command
        self.commands[name] = nil
        return true
    end
    
    return false
end

function CommandRegistry:getCommand(name)
    name = name:lower()
    
    -- Check if it's a direct command
    if self.commands[name] then
        return self.commands[name]
    end
    
    -- Check if it's an alias
    if self.aliases[name] then
        return self.commands[self.aliases[name]]
    end
    
    return nil
end

function CommandRegistry:listCommands()
    local commandList = {}
    for name, cmdInfo in pairs(self.commands) do
        table.insert(commandList, {
            name = name,
            description = cmdInfo.description,
            usage = cmdInfo.usage,
            aliases = cmdInfo.aliases
        })
    end
    return commandList
end

CommandRegistry:addCommand("status", function(playerpower, args)
    if table.find(bots, player.DisplayName) and cmdstatus then
        chatMessage(" (Bot " .. order .. ") is online!")
    end
end, {
    description = "Check the status of the bot",
    usage = "status",
    aliases = {"online"}
})

CommandRegistry:addCommand("channel", function(playerpower, args)
    if table.find(bots, player.DisplayName) and cmdchannel then
        local chnl = tonumber(args[1])
    
        if not chnl or chnl < 1 or chnl > numberbot then
            if order == channel then
                chatMessage("Error: channel must be between 1 and " .. numberbot)
            end
        else
            channel = chnl
            if order == channel then
                chatMessage("Channel is now: " .. channel)
            end
        end
    end
end, {
    description = "Set the bot's channel",
    usage = "channel <number>",
    aliases = {"ch"}
})

CommandRegistry:addCommand("admin", function(playerpower, args)
    if table.find(bots, player.DisplayName) and cmdadmin then
        if playerpower.Name == owner then
            local adminargs = args[1]
            local targetPlayerforadmin = findPlayerByName(adminargs)
        
            if targetPlayerforadmin then
                if not table.find(Admins, targetPlayerforadmin.Name) then
                    table.insert(Admins, targetPlayerforadmin.Name)
                    table.insert(adminNotConnected, targetPlayerforadmin.Name)
                    
                    local existingPlayer = game.Players:FindFirstChild(targetPlayerforadmin.Name)
                    if existingPlayer then
                        connectChatListener(existingPlayer)
                    end
                    
                    if order == channel then
                        chatMessage(targetPlayerforadmin.Name .. ' is now an admin.')
                        wait(0.25)
                        chatMessage(getgenv().prefix  .. " = prefix  say cmds for commands, args for details! ")
                    end
                else
                    if order == channel then
                        chatMessage(targetPlayerforadmin.Name .. ' is already an admin.')
                    end
                end
            else
                if order == channel then
                    chatMessage("Player not found.")
                end
            end
        else
            if order == channel then
                chatMessage("Only the owner can use this command.")
            end
        end
    end
end, {
    description = "Add an admin",
    usage = "admin (player)",
    aliases = {"addadmin"}
})

CommandRegistry:addCommand("unadmin", function(playerpower, args)
    if table.find(bots, player.DisplayName) and cmdunadmin then
        if playerpower.Name == owner then
            local unadminargs = args[1]
            local targetPlayerforunadmin = findPlayerByName(unadminargs)
        
            if targetPlayerforunadmin then
                local adminOrder = table.find(Admins, targetPlayerforunadmin.Name)
                if adminOrder then
                    table.remove(Admins, adminOrder)
                    
                    local notConnectedOrder = table.find(adminNotConnected, targetPlayerforunadmin.Name)
                    if notConnectedOrder then
                        table.remove(adminNotConnected, notConnectedOrder)
                    end
                    
                    if order == channel then
                        chatMessage(targetPlayerforunadmin.Name .. ' is no longer an admin.')
                    end
                end
            else
                if order == channel then
                    chatMessage("Player not found.")
                end
            end
        else
            if order == channel then
                chatMessage("Only the owner can use this command.")
            end
        end
    end
end, {
    description = "Remove an admin",
    usage = "unadmin (player)",
    aliases = {"removeadmin"}
})

CommandRegistry:addCommand("adminlist", function(playerpower, args)
    if table.find(bots, player.DisplayName) and cmdadminlist then
        if playerpower.Name == owner then
            if #Admins > 0 then
                if order == channel then
                    local adminListMessage = "Current Admins: " .. table.concat(Admins, ", ")
                    chatMessage(adminListMessage)
                end
            else
                if order == channel then
                    chatMessage("No admins currently added.")
                end
            end
        else
            if order == channel then
                chatMessage("Only the owner can view the admin list.")
            end
        end
    end
end, {
    description = "List current admins",
    usage = "adminlist",
    aliases = {"admins"}
})

CommandRegistry:addCommand("end", function(playerpower, args)
    if table.find(bots, player.DisplayName) and cmdend then
        if playerpower.Name == owner then
            cmdstatus = false
            cmdargs = false
            cmdchannel = false
            cmdorder = false
            cmdleft = false
            cmdright = false
            cmdup = false
            cmddown = false
            cmdend = false
            cmdorbit = false
            cmdorbit2 = false
            orbitbool = false
            orbit2bool = false
            cmddance = false
            cmdundance = false
            cmdreset = false
            cmdjump = false
            cmdsay = false
            cmdreset = false
            cmdgoto = false
            cmdadminlist = false
            cmdadmin = false
            cmdunadmin = false
            adminbool = false
            cmdcmds = false
            towerbool = false
            cmdtower = false
            cmduntower = false
            cmdfix = false
            cmdfling = false
            flingbool = false
            cmdexplode = false
            cmdelevator = false
            elevatorbool = false
            cmdbridge = false
            bridgebool = false
            cmdunbridge = false
            cmdfireworks = false
            cmdnuke = false
            cmdgravity = false
            cmdsit = false
            cmdunsit = false
            cmdladder = false
            cmdunladder = false
            ladderbool = false
            cmdragdoll = false
            cmdunragdoll = false
            cmdsword = false
            cmdunsword = false
            swordbool = false
            cmdshotgun = false
            shotgunbool = false
            cmdgun = false
            gunbool = false
            walkflingbool = false
            cmdwalkfling = false
            cmdunwalkfling = false
            cmdsmite = false
            smitebool = false
            cmdfreeze = false
            cmdunfreeze = false
            freezebool = false
            cmdcopyanim = false
            cmdlevitate = false
            cmdfloathead = false
            cmdshuffle = false
            cmdclear = false
            cmdhaunt = false
            cmdunhaunt = false
            hauntbool = false
            cmderuption = false
            eruptionbool = false
            cmdfakeout = false
            cmdstareat = false
            cmdunstareat = false
            stareatbool = false
            cmdantichatlogs = false
            cmdunantichatlogs = false
            cmddroptools = false
            cmdgrabtools = false
            cmdungrabtools = false
            grabtoolsbool = false
            cmdusetools = false
            cmdusetool = false
            cmdperformanceboost = false
            cmdfps = false
            Admins = {}
            adminNotConnected = {}
            chatMessage("Ended Script.")
        end
    end
end, {
    description = "End the script and reset all settings",
    usage = "end",
    aliases = {"terminate", "stop, quit"}
})

CommandRegistry:addCommand("order", function(playerpower, args)
    if table.find(bots, player.DisplayName) and cmdorder then
        chatMessage("(" .. order .. ")")
    end
end, {
    description = "Show the bot's current order",
    usage = "order",
    aliases = {"num, index"}
})

CommandRegistry:addCommand("dance", function(playerpower, args)
    if table.find(bots, player.DisplayName) and cmddance then
        chatMessage("/e dance")
    end
end, {
    description = "Perform default dance",
    usage = "/dance - Performs the default dance emote",
    aliases = {"d"}
})

CommandRegistry:addCommand("dance1", function(playerpower, args)
    if table.find(bots, player.DisplayName) and cmddance then
        chatMessage("/e dance1")
    end
end, {
    description = "Perform dance 1",
    usage = "/dance1 - Performs dance emote 1",
    aliases = {"d1"}
})

CommandRegistry:addCommand("dance2", function(playerpower, args)
    if table.find(bots, player.DisplayName) and cmddance then
        chatMessage("/e dance2")
    end
end, {
    description = "Perform dance 2",
    usage = "/dance2 - Performs dance emote 2",
    aliases = {"d2"}
})

CommandRegistry:addCommand("dance3", function(playerpower, args)
    if table.find(bots, player.DisplayName) and cmddance then
        chatMessage("/e dance3")
    end
end, {
    description = "Perform dance 3",
    usage = "/dance3 - Performs dance emote 3",
    aliases = {"d3"}
})

CommandRegistry:addCommand("dance4", function(playerpower, args)
    if table.find(bots, player.DisplayName) and cmddance then
        chatMessage("/e dance4")
    end
end, {
    description = "Perform dance 4",
    usage = "/dance4 - Performs dance emote 4",
    aliases = {"d4"}
})

CommandRegistry:addCommand("cmds", function(playerpower, args)
    if table.find(bots, player.DisplayName) and cmdcmds then
        if order == channel then
            local cmdMessages = {
                "orbit (p) <r> <s> | unorbit | goto (p) | reset | spin <n> | unspin | dance <n> | undance | firework (op)",
                "elevator (p) | explode (op) | fling (p) | bridge (p) <d> <s> | nuke (p) <h> <v> | gravity <n> | sit | unsit",
                "ladder (p) | ragdoll | unragdoll | jump | sword (p) <d> <sp> <v> | unsword | shotgun (p) <d> | smite (p) <h> <v>",
                "walkfling | unwalkfling | say (text) | clear | shuffle | floathead | levitate | haunt (p) | eruption (p) <v>",
                "left (p) <sp> | right (p) <sp> | up (p) <sp> | down (p) <sp> | copyanim (p) <s> | fakeout | stareat (p) | unstareat",
                "droptools | grabtools | ungrabtools | usetools (amount) (delay) | usetool <n> | perfomanceboost | fps <n>",
                " args | status | channel <n> | order | end | cmds | admin (p) | unadmin (p) | adminlist "
            }
            
            for _, msg in ipairs(cmdMessages) do
                chatMessage(msg)
                wait(0.25)
            end
        end
    end
end, {
    description = "Show available commands",
    usage = "cmds",
    aliases = {"commands", "help"}
})

CommandRegistry:addCommand("args", function(playerpower, args)
    if table.find(bots, player.DisplayName) and cmdargs then
        if order == channel then
            chatMessage(getgenv().prefix .. " = prefix | (p) = person | (op) = optional player | <r> = radius | <s> = speed | <n> = number | <d> = distance | <sp> = spacing | <v> = velocity | <t> = time")
        end
    end
end, {
    description = "Show command argument explanations",
    usage = "args",
    aliases = {"arguments"}
})

CommandRegistry:addCommand("performanceboost", function(playerpower, args)
    if table.find(bots, player.DisplayName) and cmdperformanceboost then
        performanceboost()
    end
end, {
    description = "Boost game performance by reducing graphics quality",
    usage = "performanceboost",
    aliases = {"perfboost", "lowgraphics"}
})

CommandRegistry:addCommand("fps", function(playerpower, args)
    if table.find(bots, player.DisplayName) and cmdfps then
        local number = args[1]
        fps(number)
    end
end, {
    description = "Set or remove FPS cap",
    usage = "fps <number>",
    aliases = {"setfps", "fpscap, maxfps"}
})

-- Left Command
CommandRegistry:addCommand("left", function(playerpower, args)
    if table.find(bots, player.DisplayName) and cmdleft then
        disablebool()
        local targetName = args[1]
        local spacing = tonumber(args[2]) or 5
        local targetPlayer = findPlayerByName(targetName)
        
        if targetPlayer then
            left(targetPlayer, spacing)
        end
    end
end, {
    description = "Move to the left of a player",
    usage = "left (player) <spacing>",
    aliases = {"l"}
})

-- Right Command
CommandRegistry:addCommand("right", function(playerpower, args)
    if table.find(bots, player.DisplayName) and cmdright then
        disablebool()
        local targetName = args[1]
        local spacing = tonumber(args[2]) or 5
        local targetPlayer = findPlayerByName(targetName)
        
        if targetPlayer then
            right(targetPlayer, spacing)
        end
    end
end, {
    description = "Move to the right of a player",
    usage = "right (player) <spacing>",
    aliases = {"r"}
})

-- Up Command
CommandRegistry:addCommand("up", function(playerpower, args)
    if table.find(bots, player.DisplayName) and cmdup then
        disablebool()
        local targetName = args[1]
        local spacing = tonumber(args[2]) or 5
        local targetPlayer = findPlayerByName(targetName)
        
        if targetPlayer then
            up(targetPlayer, spacing)
        end
    end
end, {
    description = "Move up relative to a player",
    usage = "up (player) <spacing>",
    aliases = {"u"}
})

CommandRegistry:addCommand("down", function(playerpower, args)
    if table.find(bots, player.DisplayName) and cmddown then
        disablebool()
        local targetName = args[1]
        local spacing = tonumber(args[2]) or 5
        local targetPlayer = findPlayerByName(targetName)
        
        if targetPlayer then
            down(targetPlayer, spacing)
        end
    end
end, {
    description = "Move down relative to a player",
    usage = "down (player) <spacing>",
    aliases = {"d"}
})

CommandRegistry:addCommand("clear", function(playerpower, args)
    if table.find(bots, player.DisplayName) and cmdclear then
        clear()
    end
end, {
    description = "Clear any ongoing bot actions",
    usage = "/clear - Stops current bot activities",
    aliases = {"c"}
})

CommandRegistry:addCommand("antichatlogs", function(playerpower, args)
    if table.find(bots, player.DisplayName) and cmdantichatlogs then
        antilogs()
        
        if order == channel then
            chatMessage("Anti chat logs enabled.")
        end
    end
end, {
    description = "Enable anti-chat logging",
    usage = "antichatlogs",
    aliases = {"antichatlog", "preventlogs, antilogs"}
})

CommandRegistry:addCommand("unantichatlogs", function(playerpower, args)
    if table.find(bots, player.DisplayName) and cmdunantichatlogs then
        unantilogs()
    end
end, {
    description = "Disable anti-chat logging",
    usage = "unantichatlogs",
    aliases = {"unanti", "allowlogs"}
})

CommandRegistry:addCommand("droptools", function(playerpower, args)
    if table.find(bots, player.DisplayName) and cmddroptools then
        dropTools()
    end
end, {
    description = "Drop all tools",
    usage = "droptools",
    aliases = {"droptool", "drop"}
})

CommandRegistry:addCommand("grabtools", function(playerpower, args)
    if table.find(bots, player.DisplayName) and cmdgrabtools then
        grabtools()
    end
end, {
    description = "Grab nearby tools",
    usage = "grabtools",
    aliases = {"pickuptools", "grab"}
})

CommandRegistry:addCommand("ungrabtools", function(playerpower, args)
    if table.find(bots, player.DisplayName) and cmdungrabtools then
        ungrabtools()
    end
end, {
    description = "Release grabbed tools",
    usage = "ungrabtools",
    aliases = {"releasetool", "ungrab"}
})

CommandRegistry:addCommand("usetools", function(playerpower, args)
    if table.find(bots, player.DisplayName) and cmdusetools then
        disablebool()
        local amount = tonumber(args[1]) or 1
        local delay = tonumber(args[2]) or false
        
        usetools(amount, delay)
    end
end, {
    description = "Use tools with optional amount and delay",
    usage = "usetools <amount> <delay>",
    aliases = {"usetoolsmulti", "multiuse"}
})

CommandRegistry:addCommand("usetool", function(playerpower, args)
    if table.find(bots, player.DisplayName) and cmdusetool then
        disablebool()
        local slotNumber = tonumber(args[1]) or 1
        
        usetool(slotNumber)
    end
end, {
    description = "Use a specific tool by slot number",
    usage = "usetool <slot>",
    aliases = {"selecttool", "toolslot, use"}
})

CommandRegistry:addCommand("ragdoll", function(playerpower, args)
    if table.find(bots, player.DisplayName) and cmdragdoll then
        ragdoll()
    end
end, {
    description = "Ragdoll the bot",
    usage = "ragdoll",
    aliases = {"rd", "ragdollmode"}
})

CommandRegistry:addCommand("unragdoll", function(playerpower, args)
    if table.find(bots, player.DisplayName) and cmdunragdoll then
        unragdoll()
    end
end, {
    description = "Disable ragdoll state",
    usage = "unragdoll",
    aliases = {"unrd", "stopragdoll"}
})

CommandRegistry:addCommand("stareat", function(playerpower, args)
    if table.find(bots, player.DisplayName) and cmdstareat then
        disablebool()
        local playerName = args[1]
        local targetPlayer = findPlayerByName(playerName)
        
        if targetPlayer then
            stareat(targetPlayer)
        end
    end
end, {
    description = "Stare at a specific player",
    usage = "stareat (player)",
    aliases = {"stare", "lookAt"}
})

CommandRegistry:addCommand("unstareat", function(playerpower, args)
    if table.find(bots, player.DisplayName) and cmdunstareat then
        stareatbool = false
    end
end, {
    description = "Stop staring at a player",
    usage = "unstareat",
    aliases = {"stopstare", "unstare"}
})

CommandRegistry:addCommand("sit", function(playerpower, args)
    if table.find(bots, player.DisplayName) and cmdsit then
        sit()
    end
end, {
    description = "Make the bot sit",
    usage = "sit",
    aliases = {"sitting"}
})

CommandRegistry:addCommand("unsit", function(playerpower, args)
    if table.find(bots, player.DisplayName) and cmdunsit then
        unsit()
    end
end, {
    description = "Make the bot stand up",
    usage = "unsit",
    aliases = {"standup"}
})

CommandRegistry:addCommand("undance", function(playerpower, args)
    if table.find(bots, player.DisplayName) and cmddance then
        player.Character.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        undance()
    end
end, {
    description = "Stop dancing",
    usage = "undance",
    aliases = {"stopdance"}
})

CommandRegistry:addCommand("noclip", function(playerpower, args)
    if table.find(bots, player.DisplayName) and cmdnoclip then
        noclip()
    end
end, {
    description = "Enable noclip mode",
    usage = "noclip",
    aliases = {}
})

CommandRegistry:addCommand("clip", function(playerpower, args)
    if table.find(bots, player.DisplayName) and cmdclip then
        clip()
    end
end, {
    description = "Disable noclip mode",
    usage = "clip",
    aliases = {}
})

CommandRegistry:addCommand("say", function(playerpower, args)
    if table.find(bots, player.DisplayName) and cmdsay then
        local msgcontent = table.concat(args, " ")
        chatMessage(msgcontent)
    end
end, {
    description = "Send a chat message",
    usage = "say <message>",
    aliases = {"chat", "message"}
})

CommandRegistry:addCommand("fix", function(playerpower, args)
    if table.find(bots, player.DisplayName) and cmdfix then
        fix()
    end
end, {
    description = "Attempt to fix bot's current state",
    usage = "fix",
    aliases = {"repair"}
})

CommandRegistry:addCommand("jump", function(playerpower, args)
    if table.find(bots, player.DisplayName) and cmdjump then
        player.Character.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
    end
end, {
    description = "Make the bot jump",
    usage = "jump",
    aliases = {}
})

-- Haunt Commands
CommandRegistry:addCommand("haunt", function(playerpower, args)
    if table.find(bots, player.DisplayName) and cmdhaunt then
        disablebool()
        local playerName = args[1]
        local targetPlayer = findPlayerByName(playerName)
        if targetPlayer then
            haunt(targetPlayer)
        end
    end
end, {
    description = "Haunt a specific player",
    usage = "haunt (player)",
    aliases = {}
})

CommandRegistry:addCommand("unhaunt", function(playerpower, args)
    if table.find(bots, player.DisplayName) and cmdunhaunt then
        hauntbool = false
    end
end, {
    description = "Stop haunting",
    usage = "unhaunt",
    aliases = {}
})

CommandRegistry:addCommand("fling", function(playerpower, args)
    if table.find(bots, player.DisplayName) and cmdfling then
        disablebool()
        local playerName = args[1]
        local targetPlayer = findPlayerByName(playerName)
        if targetPlayer then
            fling(targetPlayer)
        end
    end
end, {
    description = "Fling a specific player",
    usage = "fling (player)",
    aliases = {"f"}
})

CommandRegistry:addCommand("unfling", function(playerpower, args)
    if table.find(bots, player.DisplayName) and cmdunfling then
        flingbool = false
    end
end, {
    description = "Stop flinging",
    usage = "unfling",
    aliases = {"uf"}
})

-- Walk Fling Commands
CommandRegistry:addCommand("walkfling", function(playerpower, args)
    if table.find(bots, player.DisplayName) and cmdwalkfling then
        disablebool()
        walkfling()
    end
end, {
    description = "Enable walk fling mode",
    usage = "walkfling",
    aliases = {"wf"}
})

CommandRegistry:addCommand("unwalkfling", function(playerpower, args)
    if table.find(bots, player.DisplayName) and cmdunwalkfling then
        walkflingbool = false
    end
end, {
    description = "Disable walk fling mode",
    usage = "unwalkfling",
    aliases = {"unwf"}
})

-- Fakeout Command
CommandRegistry:addCommand("fakeout", function(playerpower, args)
    if table.find(bots, player.DisplayName) and cmdfakeout then
        fakeout()
    end
end, {
    description = "Perform a fakeout action",
    usage = "fakeout",
    aliases = {}
})

CommandRegistry:addCommand("sword", function(playerpower, args)
    if table.find(bots, player.DisplayName) and cmdsword then
        disablebool()
        local targetName = args[1]
        local initialDistance = tonumber(args[2]) or 20
        local subsequentSpacing = tonumber(args[3]) or 5
        local velocityMagnitude = tonumber(args[4]) or -500
        local targetPlayer = findPlayerByName(targetName)
      
        if targetPlayer then
            sword(targetPlayer, initialDistance, subsequentSpacing, velocityMagnitude)
        end 
    end
end, {
    description = "Sword attack a player",
    usage = "sword (player) <distance> <spacing> <velocity>",
    aliases = {}
})

CommandRegistry:addCommand("unsword", function(playerpower, args)
    if table.find(bots, player.DisplayName) and cmdunsword then
        swordbool = false
    end
end, {
    description = "Stop sword attack",
    usage = "unsword",
    aliases = {}
})

-- Shotgun Command
CommandRegistry:addCommand("shotgun", function(playerpower, args)
    if table.find(bots, player.DisplayName) and cmdshotgun then
        disablebool()
        local targetName = args[1]
        local initialDistance = tonumber(args[2]) or 9
        local targetPlayer = findPlayerByName(targetName)
      
        if targetPlayer then
            shotgun(targetPlayer, initialDistance)
        end
    end
end, {
    description = "Perform a shotgun attack on a player",
    usage = "shotgun (player) <distance>",
    aliases = {"sg"}
})

-- Smite Command
CommandRegistry:addCommand("smite", function(playerpower, args)
    if table.find(bots, player.DisplayName) and cmdsmite then
        disablebool()
        local targetName = args[1]
        local height = tonumber(args[2]) or 100
        local velocity = tonumber(args[3]) or 500
        local targetPlayer = findPlayerByName(targetName)
      
        if targetPlayer then
            smite(targetPlayer, height, velocity)
        end
    end
end, {
    description = "Smite a specific player",
    usage = "smite (player) <height> <velocity>",
    aliases = {}
})

local function modifiedChatHandler(playerpower, message)
    -- Check if the message starts with the prefix
    if message:sub(1, #prefix) == prefix then
        -- Remove the prefix and split the message into parts
        local commandText = message:sub(#prefix + 1)
        local parts = {}
        for part in commandText:gmatch("%S+") do
            table.insert(parts, part)
        end
        
        -- Get the command name (first part) and convert to lowercase
        local commandName = table.remove(parts, 1):lower()
        
        -- Check if the player is an admin or the owner
        if playerpower.Name == owner or table.find(Admins, playerpower.Name) then
            -- Try to find the command in the registry
            local command = CommandRegistry:getCommand(commandName)
            
            if command then
                -- Check if the bot is part of the bots list
                if table.find(bots, player.DisplayName) then
                    -- Execute the command
                    command.func(playerpower, parts)
                end
            else
                -- If command is not found, send a message
                if order == channel then
                    chatMessage("Unknown command: " .. commandName)
                end
            end
        else
            -- If the player is not authorized
            if order == channel then
                chatMessage("You are not authorized to use commands.")
            end
        end
    end
end

-- Chat Listener Function
local function connectChatListener(playerpower)
    playerpower.Chatted:Connect(function(message)
        modifiedChatHandler(playerpower, message)
    end)
end

--listen to owner
if ownerPlayer then
    connectChatListener(ownerPlayer)
end

--listen to admins
while adminbool do
    for _, adminName in pairs(adminNotConnected) do
        local adminPlayer = game.Players:FindFirstChild(adminName)
        if adminPlayer then
            connectChatListener(adminPlayer)
            table.remove(adminNotConnected, table.find(adminNotConnected, adminName))
        end
    end
    wait(2)
end

--listen to admins
game.Players.PlayerAdded:Connect(function(player)
    if table.find(Admins, player.Name) then
        connectChatListener(player)
    end
end)
